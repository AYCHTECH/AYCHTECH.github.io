<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>오픈소스컨설팅 기술 블로그</title>
    <description>기술을 나눕니다. 함께 성장합니다.
Sharing Tech. Growing Together.
</description>
    <link>https://tech.osci.kr/</link>
    <atom:link href="https://tech.osci.kr/rss" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 12 Aug 2018 02:24:21 +0900</pubDate>
    <lastBuildDate>Sun, 12 Aug 2018 02:24:21 +0900</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>우리는 왜, 무료로 Jira 교육을 하고 유료교육을 위해 만든 매뉴얼을 무료로 배포하기로 결정했을까?</title>
        <description>&lt;p&gt;
 안녕하세요, 오픈소스컨설팅에서 아틀라시안팀을 맡고 있는 한진규 이사입니다
&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
 요즘 날씨가 엄청 덥네요.
&lt;/p&gt;
&lt;p&gt;
 찌는 듯한 더위가 가실지 모르고 에어컨을 틀게 만들더니, 오늘은 또 소나기와 함께 동남아 한가운데 서있는 듯 한 습한기운으로 아직 여름이 한참 남았다고 굳이 온몸으로 느끼게 해주네요.
&lt;/p&gt;
&lt;p&gt;
 아
 &lt;s&gt;
  18 john 나
 &lt;/s&gt;
 더워....라는 말을 달고 사는건 저 뿐이 아닐 겁니다. 아 더워...
&lt;/p&gt;
&lt;p&gt;
 가을이 그리운 건 저 뿐만이 아니겠지만, 오지 않은 가을을 기다리는 것보다는 지금 이미 와 있는 이 여름도 즐기는 게 더 중요하다고 생각 합니다. 크~ 갬성~
 &lt;s&gt;
  아니고 아재인증
 &lt;/s&gt;
&lt;/p&gt;
&lt;p&gt;
 날씨가 더워서 이야기가 산으로 가고 있습니다..크흠...
&lt;/p&gt;
&lt;p&gt;
 그럼 이제 본론으로 들어가 볼까요?
&lt;/p&gt;

&lt;h1 id=&quot;id-우리는왜,무료로Jira교육을하고유료교육을위해만든매뉴얼을무료로배포하기로결정했을까?-시작&quot;&gt;
 시작
&lt;/h1&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 사실 예전부터 Jira와 Confluence에 대해서 많은 고민이 있었습니다.
&lt;/p&gt;
&lt;p&gt;
 외국산 (잘 아시다시피, Jira와 Confluence는 Atlassian이라는 호주 회사에서 만들었죠) 소프트웨어이다 보니, 한국에서 사용하기에 불편함이 많은 것이 사실입니다.
&lt;/p&gt;
&lt;p&gt;
 요즘은 초기에 비해 많은 개선이 이루어져서 한글화 등이 잘 되어 있지만, 사용법이나 Trouble shooting을 위한 가이드들은 여전히 영어로 되어 있는 경우가 많습니다.
&lt;/p&gt;
&lt;p&gt;
 파파고와 구글 번역이 열일하고 있어서(조금만 더 힘내줘~!!) 불편함이 많이 줄기는 했지만,
&lt;/p&gt;
&lt;p&gt;
 한글로 된 정보가 적다는 것은 아무래도 초기 접근성을 떨어뜨리기도 하고 내포된 많은 기능과 의미를  제대로 파악하는데 있어서도 큰 제약이 됩니다.
&lt;/p&gt;

&lt;p&gt;
 그래서 저는 친한 친구이자, Atlassian 전도사인 디프로그웍스 신철민대표와 책을 하나 써보자...라는 말을 자주 했었습니다.
&lt;/p&gt;
&lt;p&gt;
 제대로된 Jira/Confluence 메뉴얼을 만들어보자는 것이었죠.
 &lt;s&gt;
  (왠지 돈을 많이 벌수 있을것 같아!)
 &lt;/s&gt;
&lt;/p&gt;
&lt;p&gt;
 그런데 그게 어디 쉽습니까?
&lt;/p&gt;
&lt;p&gt;
 잘 아시겠지만 하는 업무가 바쁜데 취미로 매뉴얼을 만든다는게 말이 쉽지 실제로 실행하지는 못했죠.
 &lt;s&gt;
  그냥 의지박약
 &lt;/s&gt;
&lt;/p&gt;
&lt;p&gt;
 핑계가 아니라
 &lt;s&gt;
  핑계맞음
 &lt;/s&gt;
 , 그때만 해도 저는 일반 회사에서
 &lt;s&gt;
  32500개의
 &lt;/s&gt;
 여러업무 중 하나로 Jira/Confluence를 담당하고 있었고,
&lt;/p&gt;
&lt;p&gt;
 Jira/Confluence 이 외에도 할 일이 너무
 &lt;s&gt;
  너무너무너무너무
 &lt;/s&gt;
 많았기 때문에 그렇게 그냥 말만 앞세운 채 시간은 흘러갔습니다.
&lt;/p&gt;

&lt;h1 id=&quot;id-우리는왜,무료로Jira교육을하고유료교육을위해만든매뉴얼을무료로배포하기로결정했을까?-진짜시작&quot;&gt;
 진짜 시작
&lt;/h1&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;p&gt;
 그러다 저는 좋은 기회로 오픈소스컨설팅에 합류하게 되었고, 본격적으로 Atlassian 제품에 대한 Presales와 Consulting 업무를 맡게 되었습니다. (올레~!)
&lt;/p&gt;
&lt;p&gt;
 하고싶은 일, 좋아하는 일, 관심있는 일을 직업으로 갖는 다는건 참 행운이었죠.
&lt;/p&gt;
&lt;p&gt;
 덕분에 짧은 시간동안 많은 사례들을 접할 수 있었고, 일에 빠져들수록 예전에 생각 했던 메뉴얼 작업과 교육이 정말 중요한 부분이라는 것을 다시한번 깨닫게 되었습니다.
&lt;/p&gt;
&lt;p&gt;
 좋은건 알지만 아무래도 매일매일 해야하는 업무가 있기 때문에 '교육프로그램'이라는 새로운 프로젝트를 꾸려나가기가 쉽지 않았는데
&lt;/p&gt;
&lt;p&gt;
 다행히 우리 팀 구성원들이 Open mind를 갖고 있는 분들이라, 새로운 프로젝트를 겁도 없이 시작할수 있었지요.
 &lt;s&gt;
  힘들죠? 우리팀...ㅠㅠ
 &lt;/s&gt;
&lt;/p&gt;
&lt;p&gt;
 더불어, 신철민대표도 본인 회사 운영하는데 바쁜데도 불구하고 교육 프로그램 런칭 프로젝트에 동참해 주었습니다.
&lt;/p&gt;
&lt;p&gt;
 그는 이미 여러 곳에서 다양한 형태로 Jira/Confluence 교육을 해왔던 베테랑이기 때문에, 저는 천군만마를 얻은 듯이 기뻤습니다.
 &lt;s&gt;
  (신대표님, 이 정도면 충분히 칭찬 했지?)
 &lt;/s&gt;
&lt;/p&gt;

&lt;h1 id=&quot;id-우리는왜,무료로Jira교육을하고유료교육을위해만든매뉴얼을무료로배포하기로결정했을까?-고민&quot;&gt;
 고민
&lt;/h1&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 암튼 그렇게 시작된 프로젝트가  바로 지금 운영중인
 &lt;a class=&quot;external-link&quot; href=&quot;http://osci.kr/training/training.php&quot; rel=&quot;nofollow&quot;&gt;
  &lt;strong&gt;
   Atlassian Training Program by Opensource Consulting
  &lt;/strong&gt;
 &lt;/a&gt;
 입니다.
&lt;/p&gt;
&lt;p&gt;
 다만, 초기 구상시에는 모든 프로그램이 유료였고, 유료교육이니 만큼 고객이 돈을 지불하는 그 이상의 가치를 전달하기 위해 깊이 있는 교육 프로그램을 구상하고 준비했습니다.
&lt;/p&gt;
&lt;p&gt;
 다양한 변수 및 회사의 이윤과 고객의 혜택 사이에서 어느 한 쪽에 쏠리지 않고 모두가 행복할 수 있도록 프로그램당 최소인원과 최대인원, 비용 등을 책정 했습니다.
&lt;/p&gt;
&lt;p&gt;
 Training Program 오픈 시기가 가까워 오던 어느날, 우리는 좀 다른 부분에서 고민을 하게 되었습니다.
&lt;/p&gt;
&lt;p&gt;
 바로 교육 자료의 제공범위에 대한 부분이었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 통상적으로 우리가 외부 기관에서 교육을 받게 되면 교육을 받은 사람이 아니면 알수 없는 뭔가 알맹이가 빠진 교재를 제공 받고,
&lt;/p&gt;
&lt;p&gt;
 교육수료의 훈장, 증표 처럼 그 책자를 들고 사무실에 와서는 그냥 서랍이나 책장에 처박아두고 잊어버리기 마련입니다. 왜냐면 다시 꺼내봐도 뭔소린지 모르게 되어 있거든요.
&lt;/p&gt;
&lt;p&gt;
 그리고 강사의 PPT자료를 안주는 경우도 많아서, 좀 뭔가 아쉽기도 했고요.
&lt;/p&gt;

&lt;p&gt;
 그래서 저희는,  &quot;다 때려 넣자. 괜히 뭐 숨기고, 알맹이 빼고 그런거 하지 말고 제대로 다 넣자. 나중에 매뉴얼로 쓸수 있도록 만들자.&quot;라는 걸 모토로 교육자료를 만들게 되었고,
&lt;/p&gt;
&lt;p&gt;
 그 이후 오히려 이런 생각이 들었죠.
&lt;/p&gt;
&lt;p&gt;
 '유료교육 수료한 분들만 주기엔 이 자료가 너~무 아깝다.....'
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 모든 사람이 제약없이 Jira를 써보고 업무 생산성을 높이면 좋겠는데 유료교육을 들은 사람들만 주면 이렇게 열심히 만든게 오히려 아까운게 아닌가?
&lt;/p&gt;
&lt;p&gt;
 무료 배포하는게 어떨까? 라는 이야기가 내부에서 나온거죠.
 &lt;s&gt;
  니들 월급은 뭘로주니
 &lt;/s&gt;
&lt;/p&gt;
&lt;p&gt;
 흠..착한 사람들...
&lt;/p&gt;
&lt;p&gt;
 특히나 자료를 만드는데 너무 고생을 많이 했을 신철민 대표가 오히려 무료로 풀자고 하더군요. 우리 팀원들도 맞장구.
 &lt;s style=&quot;letter-spacing: 0.0px;&quot;&gt;
  나만왕따
 &lt;/s&gt;
&lt;/p&gt;

&lt;p&gt;
 하지만, 자료를 무료로 풀면 이에 맞춰 실시할 Basic Session을 유료로 운영하는게 맞나? 라는 생각까지 이어졌고,
&lt;/p&gt;
&lt;p&gt;
 비용과 다양한 문제들이 있기 때문에 쉽게 결정할 수 있는 문제는 아니었습니다.
&lt;/p&gt;
&lt;p&gt;
 아무래도 회사는 자선사업을 하는 곳은 아니니까요.
&lt;/p&gt;

&lt;p&gt;
 결국 고민 끝에 회사 대표님과 지웅님(aka.공동창업자)께 이러한 내용을 말씀드리고 의견을 어쭤보았습니다.
 &lt;s&gt;
  이런 말 했다가 땅파서 장사하냐고 욕들어 먹는거 아닌가 싶어서 엄청쫄았다
 &lt;/s&gt;
&lt;/p&gt;
&lt;p&gt;
 마케팅을 위해 이런 것도 필요하다는 장황한 설명을 준비해서 보고 드리는데,
&lt;/p&gt;
&lt;p&gt;
 우리 대표님과 지웅님 너무 cool하게, &quot;무료로 해요&quot; 라고 하셨습니다.
 &lt;s&gt;
  돈벌생각이 없으신가..
 &lt;/s&gt;
&lt;/p&gt;

&lt;h1 id=&quot;id-우리는왜,무료로Jira교육을하고유료교육을위해만든매뉴얼을무료로배포하기로결정했을까?-초심을잃지말자&quot;&gt;
 초심을 잃지말자
&lt;/h1&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 왜 처음에 우리가 이런 교육을 기획 했을까?
&lt;/p&gt;
&lt;p&gt;
 많은 사람이 좋은 Tool을 제약없이 쓰게 하는게 목표였죠.
&lt;/p&gt;
&lt;p&gt;
 제가 사용자일 때 부터 솔루션 파트너인 지금까지, 외국산 소프트웨어여서 불편해 하는 사람은 없었으면 좋겠다는 생각은 변함이 없고, 그 생각 때문에 이 모든게 시작 됐다는 걸 오랜만에 되새기게 되었죠.
 &lt;s&gt;
  머리가 나쁘면 고생
 &lt;/s&gt;
&lt;/p&gt;

&lt;p&gt;
 또한, 우리 회사가 중요하게 생각하는 항목 중에 하나가, &quot;고객의 이득을 최우선으로 하자&quot; 인데, 이에 부합하는 좋은 케이스였던 거죠.
&lt;/p&gt;
&lt;p&gt;
 여전히 우물 안 개구리인 저는 좋은 팀구성원들, 파트너, 선배님들을 만나서 오늘도 성장하며 우물 밖으로 슬슬 점프하려고 시도하고 있습니다.
 &lt;s&gt;
  이 나이에 아직도 성장한다는게 신기
 &lt;/s&gt;
&lt;/p&gt;

&lt;p&gt;
 우리가 유료교육으로 열심히 준비했던 Jira Basic Course는 이렇게 무료교육으로 전환되었고, 강의자료도 무료 배포하게 되었습니다.
&lt;/p&gt;

&lt;h1 id=&quot;id-우리는왜,무료로Jira교육을하고유료교육을위해만든매뉴얼을무료로배포하기로결정했을까?-감사함도잊지말자&quot;&gt;
 감사함도 잊지말자
&lt;/h1&gt;

&lt;p&gt;
 이 과정을 준비하며,
&lt;/p&gt;
&lt;p&gt;
 자기 업무 하나하나 너무 바쁜데 신경써주고 의견 함께 해준 팀구성원들이 너무 고맙고,
&lt;/p&gt;
&lt;p&gt;
 자료준비와 강의준비로 고생했던 디프로그웍스 신철민 대표도 너무 고맙고,
&lt;/p&gt;
&lt;p&gt;
 강의 외의 모든 준비를 급작스럽게 해줘야 했는데, 늘 웃으면서 도와주신 우리 마케팅팀의 혜진님, 현수님 너무나 고맙고, (포스터, 진행 모두 짱짱!!)
&lt;/p&gt;
&lt;p&gt;
 마케팅이라는
 &lt;s&gt;
  말같지도않은
 &lt;/s&gt;
 포장을 가감없이 받아주시고, 강의료, 대관료 등등 비용을 믿고 지원해주시는 대표님, 지웅님 너무 감사 했습니다.
&lt;/p&gt;

&lt;p&gt;
 저희 오픈소스컨설팅 아틀라시안팀은 더 많은 분들이 Jira/Confluene를 편하게 사용하실 그 날을 위해 좀 더 노력 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
 Jira 강의자료는 아래 사이트에서 다운로드 받으실 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://osci.kr/training/training.php&quot; rel=&quot;nofollow&quot;&gt;
  http://osci.kr/training/training.php
 &lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
 그리고 매월 있을
 &lt;strong&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://www.osci.kr/training/training.php&quot; rel=&quot;nofollow&quot;&gt;
   Atlassian Training by Opensource Consulting
  &lt;/a&gt;
 &lt;/strong&gt;
 에도 많은관심 부탁드립니다.
&lt;/p&gt;
&lt;p&gt;
 더 좋은 교육으로 찾아뵙겠습니다.
&lt;/p&gt;

&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Aug 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/atlassian/2018/08/09/44205753/</link>
        <guid isPermaLink="true">https://tech.osci.kr/atlassian/2018/08/09/44205753/</guid>
        
        <category>Jira</category>
        
        <category>교육</category>
        
        <category>Atlassian</category>
        
        
        <category>Atlassian</category>
        
      </item>
    
      <item>
        <title>오픈소스컨설팅 Jira 교육 후기</title>
        <description>&lt;p&gt;
 안녕하세요.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅 김세연입니다.
&lt;/p&gt;
&lt;p&gt;
 2018. 8. 9(목) 14:00 부터 Jira 교육을 했습니다. 교육 후기를 공유합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
&lt;img src=&quot;/assets/images/44205726/0&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 참고로, 오픈소스컨설팅에서는 매월 1회 Jira, Conlfuence 사용자 편의를 위해 무료 기초 교육을 하고 있습니다.  (대박!)
&lt;/p&gt;
&lt;p&gt;
 여기서 포인트는 &quot;무료&quot;
&lt;/p&gt;
&lt;p&gt;
 강좌 공지가 뜨면 하루만에 마감된다고 하니 오픈소스컨설팅 페이스북 페이지 &quot;팔로우&quot;를 통해 무료 교육기회를 Get!!! 하시기 바랍니다!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 그럼 이제부터 제대로 후기 공유 들어갑니다~
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-오픈소스컨설팅Jira교육후기-회사소개&quot;&gt;
 회사소개
&lt;/h1&gt;
&lt;p&gt;
우선 오픈소스컨설팅의 아틀라시안팀을 맡고있는 한진규 이사께서 오픈소스컨설팅 회사 소개를 진행했습니다. 주요 사업분야로는 Infra, Middleware, Openstack, Docker, System Architecture, Tomcat Manager(미어캣), Atlassian등이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 힘들고 어려운 기술들을 쉽게 적용할 수 있도록 지원하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 오늘 교육 자료는
 &lt;a class=&quot;external-link&quot; href=&quot;http://osci.kr/OSC_JIRA기본사용자교육.pdf&quot; rel=&quot;nofollow&quot;&gt;
  http://osci.kr/OSC_JIRA기본사용자교육.pdf
 &lt;/a&gt;
 링크에서 다운로드 받을 수 있습니다.
&lt;/p&gt;
&lt;h1 id=&quot;id-오픈소스컨설팅Jira교육후기-교육시작&quot;&gt;
 교육시작
&lt;/h1&gt;
&lt;p&gt;
 오픈소스컨설팅의 협력사인 디프로그웍스의 신철민 대표께서 교육을 진행해 하셨습니다.
&lt;/p&gt;
&lt;p&gt;
 신철민 대표님은 Atlassian과 프로세스 컨설팅을 하고계십니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Jira 경험을 공유해 주셨는데요 개발팀 이외에 경영, 인사, 구매 다양한 팀에서 같이 사용 경험을 공유해 주셨습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  아이스 브레이킹
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 오늘 참여 하신분들은 1년 미만인 분들과 관리자 분들이 다수 계셨습니다. 오늘 교육자료를 지금까지의 노하우를 압축 시켰다고 하십니다.
&lt;/p&gt;
&lt;p&gt;
 (정말 기대가 되는데요!)
&lt;/p&gt;
&lt;p&gt;
 이제부터 신철민 대표님 입장에서 글을 작성하도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Jira가 애자일 프로젝트에 특화되어 있지만 폭포수 모델 프로젝트를 효율적으로 관리하는 방법이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Jira는 마켓플레이스에서 애드온을 설치할 수 있습니다. 폭포수 모델을 쉽게 관리하기 위한 애드온들이 많이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  아틀라시안 소개
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 아틀라시안은 호주에서 창업을 시작했고 호주에서 가장 일하기 좋은 회사 1위입니다.
&lt;/p&gt;
&lt;p&gt;
 아틀라시안은 마켓플레이스 생태계를 갖고 있습니다. 애드온으로 성공한 서드파트 회사가 생겨나기 시작했습니다.
&lt;/p&gt;
&lt;p&gt;
 데브옵스를 구현하기 위한 모든 솔루션을 제공합니다.
&lt;/p&gt;
&lt;blockquote&gt;
 &lt;p&gt;
  하나의 회사에서 데브옵스를 구현하기 위한 모든 도구를 제공하는 회사는 전 세계에서 유일합니다.
 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
 Jira, Confluence로 기획하고 프로젝트를 트래킹할 수 있습니다. Bitbucket, Bamboo로 CI/CD를 구현하고 JSD(Jira Service Desk)로 지속적인 피드백을 받을 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 최근에는 Slack과 협력함으로써 Jira, Confluence등 강점인 사업에 집중하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Jira Software
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 IT개발 팀에게 필요한 기능이 있습니다. Scrum, Kanban Board 등 개발팀에게 필요한 기능이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Version release 기능으로 소프트웨어의 버전 관리를 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Jira Core
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 업무 팀에게 필요한 기능만 있습니다. 보드가 없고 간단한 기능만 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Jira Service Desk(JSD)
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 JSD는 agent 기반으로 라이선스를 관리합니다. agent 역할은 이슈를 접수하고 담당자에게 할당하는 역할을 합니다.
&lt;/p&gt;
&lt;p&gt;
 이슈를 접수 받고 해결되는 시간 SLA(Service Level Agreement)를 측정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 고객 포탈이 제공되고 automation 등 부가적인 기능이 제공됩니다.
&lt;/p&gt;
&lt;p&gt;
 Confluence와 연결하여 요청할 때 관련된 내용이 Confluence의 내용이 나옵니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Jira Server(self-hosted) version vs Cloud
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 기능은 크게 다르지 않지만 다른 제품이라고 보시면 됩니다.
&lt;/p&gt;
&lt;p&gt;
 UI도 차이가 나고 두 제품 개발 언어도 다릅니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  라이선스
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 서버는 영구사용 라이선스를 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 최초 구매 후 라이선스를 리뉴얼 하지 않으면 영구적으로 사용할 수 있으나 1년 후 라이선스 버전 업그레이드를 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 유지보수 라이선스는 1년 후 50% 할인된 가격으로 유지보수 계약을 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Cloud는 사용자당 월 사용비를 받고 있습니다.
&lt;/p&gt;
오늘 교육은 Jira 사용에 필요한 기본 기능을 익히는 좋은 시간 이었습니다.&lt;br/&gt;
또한 교육 중간에 자유롭게 질문과 답변하는 분위기가 좋았습니다.&lt;br/&gt;
매달 이런 무료 교육이 진행 예정입니다.&lt;br/&gt;
좋은 문화와 도구를 알리는데 좋은 기회가 됐으면 합니다.&lt;br/&gt;
 자세한 내용은 PDF를 참고하여 주시기 바랍니다.&lt;br/&gt;
&lt;embed src=&quot;/files/OSC_JIRA기본사용자교육.pdf&quot; width=&quot;100%&quot; height=&quot;300px&quot;&gt;</description>
        <pubDate>Thu, 09 Aug 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2018/08/09/44205726/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2018/08/09/44205726/</guid>
        
        
      </item>
    
      <item>
        <title>7월 Atlassian TroubleShooting 정리</title>
        <description>&lt;h2 id=&quot;id-7월AtlassianTroubleShooting정리-7월이슈사항내역&quot;&gt;
 7월 이슈사항 내역
&lt;/h2&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-일반사용자가Header의Issues메뉴(Currentsearch,Searchforissues)사용시Layout이깨지며,Browser가hang되는현상&quot;&gt;
 &lt;strong&gt;
  일반 사용자가 Header의 Issues 메뉴(Current search, Search for issues) 사용 시 Layout이 깨지며, Browser가 hang되는 현상
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    Exception :Uncaught ReferenceError :Calendar is not defined
   &lt;/li&gt;
   &lt;li&gt;
    사용하지 않는 Jira Suit Utilities plugin이 설치되어 있었으며, 해당 Add-on을 제거함으로써 해결
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-Project생성시에러발생현상&quot;&gt;
 &lt;strong&gt;
  Project 생성 시 에러발생현상
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ol&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    Caused by: java.lang.RuntimeException: Could not identify Bundle at location &amp;lt;reference:
    &lt;a class=&quot;external-link&quot; href=&quot;http://file/var/atlassian/application-data/jira/plugins/.osgi-plugins/transformed-plugins/project-templates-plugin-6.2.3_1531264928000.jar&quot; rel=&quot;nofollow&quot;&gt;
     file:/var/atlassian/application-data/jira/plugins/.osgi-plugins/transformed-plugins/project-templates-plugin-6.2.3_1531264928000.jar
    &lt;/a&gt;
    &amp;gt;
   &lt;/li&gt;
   &lt;li&gt;
    Cache된 플러그인 디렉토리가 삭제되어 발생하는 에러로, Jira 재시작 시 해결
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-JiraKanbanBoard에서이슈클릭시에러발생현상&quot;&gt;
 &lt;strong&gt;
  Jira Kanban Board에서 이슈 클릭 시 에러발생현상
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ol&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    An ssh error occurred while querying for reviews
   &lt;/li&gt;
   &lt;li&gt;
    사용하지 않는 Gerrit plugin이 설치되어 있었으며, 해당 Add-on을 제거함으로써 해결
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-UserpickercustomField문제&quot;&gt;
 &lt;strong&gt;
  User picker custom Field 문제
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ol&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    사용자가 1000명 이상인 그룹에 대해 Jira의 Custom field 중 하나인 user picker를 사용 시 해당 그룹의 최대 사용자가 1000명까지밖에 조회되지않는 현상
   &lt;/li&gt;
   &lt;li&gt;
    이는 Third-party Add-on인 Custom watcher field에서도 동일하게 발생
   &lt;/li&gt;
   &lt;li&gt;
    현재 Bug로 등록 및 에스컬레이션 진행 중이나, Fix되지 않음
    &lt;ul&gt;
     &lt;li&gt;
      &lt;a class=&quot;external-link&quot; href=&quot;https://jira.atlassian.com/browse/JRASERVER-63771&quot; rel=&quot;nofollow&quot;&gt;
       https://jira.atlassian.com/browse/JRASERVER-63771
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;
    Atlassian Bug Fix 정책에 따라, hotfix가 불가능
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-JiraFileupload문제&quot;&gt;
 &lt;strong&gt;
  Jira File upload 문제
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ol&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    Jira의 자체적인 파일업로드 사이즈 제한을 풀었음에도 파일 업로드가 되지 않는 현상
   &lt;/li&gt;
   &lt;li&gt;
    Nginx 웹서버 설정의 max_body size 를 늘림으로써 해결
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-ConfluenceTable자음분리문제&quot;&gt;
 &lt;strong&gt;
  Confluence Table 자음 분리 문제
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ol&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    Confluence Table에서 첫 Column에서 한글의 자음이 분리되는 현상
   &lt;/li&gt;
   &lt;li&gt;
    Chrome의 버그로 최신업데이트로 해결
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-JiraServiceDesk에서ConfluenceKnowledgeBase연동시Anonymous권한이있어야만하는현상&quot;&gt;
 &lt;strong&gt;
  Jira Service Desk에서 Confluence KnowledgeBase 연동 시 Anonymous 권한이 있어야만하는 현상
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    Jira의 Application link 버그로, 연결방식을 OAuth (impersonation)로 변경 시 해결
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-SSRF버그를통한취약점문제&quot;&gt;
 &lt;strong&gt;
  SSRF 버그를 통한 취약점 문제
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ol&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://www.zdnet.com/article/jira-bug-exposed-private-server-keys-at-major-companies-researcher-finds/&quot; rel=&quot;nofollow&quot;&gt;
     https://www.zdnet.com/article/jira-bug-exposed-private-server-keys-at-major-companies-researcher-finds/
    &lt;/a&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/jira-bug-exposes-organizations-aws-server-keys&quot; rel=&quot;nofollow&quot;&gt;
     https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/jira-bug-exposes-organizations-aws-server-keys
    &lt;/a&gt;
   &lt;/li&gt;
   &lt;li&gt;
    Jira / Confluence 각각 해당 취약점이 해결된 버전으로 업그레이드하여 해결
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-Log에사용자ID가남지않는문제&quot;&gt;
 &lt;strong&gt;
  Log에 사용자 ID가 남지않는 문제
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;
     192.168.1.120 - -
     &lt;span class=&quot;error&quot;&gt;
      [12/Jul/2018:14:53:16 +0900]
     &lt;/span&gt;
     0.366s - 7423 /wiki/attachmentnotfound.action?pageId=159876496
    &lt;/p&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;
     server.xml파일에 %{X-AUSERNAME}o 파라메터 추가
     &lt;br/&gt;
     &lt;a class=&quot;external-link&quot; href=&quot;https://confluence.atlassian.com/confkb/audit-confluence-using-the-tomcat-valve-component-223216846.html&quot; rel=&quot;nofollow&quot; title=&quot;Follow link&quot;&gt;
      https://confluence.atlassian.com/confkb/audit-confluence-using-the-tomcat-valve-component-223216846.html
     &lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
     &lt;span class=&quot;error&quot;&gt;
      [12/Jul/2018:15:04:19 +0900]
     &lt;/span&gt;
     testuser Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 192.168.1.120 0.042s - 672 /wiki/rest/webResources/1.0/resources
    &lt;/p&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;id-7월AtlassianTroubleShooting정리-ETC&quot;&gt;
 ETC
&lt;/h2&gt;
&lt;h3 id=&quot;id-7월AtlassianTroubleShooting정리-CrowdDataCenterMechanism관련&quot;&gt;
 Crowd Data Center Mechanism 관련
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li style=&quot;list-style-type: none;background-image: none;&quot;&gt;
  &lt;ul&gt;
   &lt;li&gt;
    Jira의 경우 ehcache를, Confluence의 경우 hazelcast를 Clustering에 사용하나 Crowd에 대한 정보를 찾기가 어려워 Support에 질의
   &lt;/li&gt;
   &lt;li&gt;
    Crowd의 경우 Jira나 Confluence만큼 복잡한 솔루션이 아니기에 DB Table 레벨에서 해결
    &lt;ul&gt;
     &lt;li&gt;
      &lt;p&gt;
       Crowd doesn't use any mechanisms like Hazelcast or ehcache to manage the cluster. It maintains the state of the cluster through tables in the database.
       &lt;br/&gt;
       Basically, Crowd is a
       &lt;em&gt;
        simpler
       &lt;/em&gt;
       application than Confluence or Jira and doesn't have any need to implement any additional clustering mechanism
       &lt;br/&gt;
       I also got the following information from one of our Crowd developers.
      &lt;/p&gt;
      &lt;blockquote&gt;
       &lt;p&gt;
        Crowd is not using cache replication among DC nodes.
        &lt;br/&gt;
        It relies on DB and there is publish - subscribe mechanism also based on DB to notify all nodes about changes in config
       &lt;/p&gt;
      &lt;/blockquote&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Tue, 07 Aug 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/atlassian/2018/08/07/44205476/</link>
        <guid isPermaLink="true">https://tech.osci.kr/atlassian/2018/08/07/44205476/</guid>
        
        <category>atlassian</category>
        
        <category>TroubleShooting</category>
        
        
        <category>atlassian</category>
        
      </item>
    
      <item>
        <title>Bitbucket jekyll 블로그 만들기</title>
        <description>&lt;p&gt;
 안녕하세요.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅 김세연입니다.
&lt;/p&gt;
&lt;p&gt;
 이번에는 Bitbucket cloud에 jekyll을 이용하여 Blog Publishing을 해보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;Bitbucketjekyll블로그만들기-BitbucketCloud회원가입&quot;&gt;
 Bitbucket Cloud 회원가입
&lt;/h1&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://bitbucket.org/account/signup/&quot; rel=&quot;nofollow&quot;&gt;
  https://bitbucket.org/account/signup/
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 gmail 또는 Atlassian 계정을 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;Bitbucketjekyll블로그만들기-Repository생성&quot;&gt;
 Repository 생성
&lt;/h1&gt;
&lt;p&gt;
 Repository를 생성할 때 이름은 Bitbucket 고유 주소의 bitbucket.io가 붙습니다.
&lt;/p&gt;
&lt;p&gt;
 저는 it2seiyon으로 회원가입을 했기 때문에
 &lt;strong&gt;
  it2seiyon.bitbucket.io
 &lt;/strong&gt;
 값으로 했습니다.
&lt;/p&gt;
&lt;p&gt;
 This is private repository 체크 해제 후 Create repository를 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/0&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 생성된 Repository의 URL을 보시면 bitbucket.org/it2seiyeon/it2seiyon.bitbucket.io를 확인할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/1&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://it2seiyon.bitbucket.io&quot; rel=&quot;nofollow&quot;&gt;
  https://it2seiyon.bitbucket.io
 &lt;/a&gt;
 접속해 보면 아직 index파일이 없어서 File not found 가 뜹니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/2&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 다른 주소 bitbucket.io를 만들고 싶으시면 Team 추가하여 만들 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 + 버튼으로 추가할 수 있으며 Team ID 또한 고유 값을 갖습니다.
&lt;/p&gt;
&lt;p&gt;
 그래야 겹치지 않는 주소를 갖겠죠?
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/3&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h1 id=&quot;Bitbucketjekyll블로그만들기-RepositoryClone&quot;&gt;
 Repository Clone
&lt;/h1&gt;
&lt;p&gt;
 Bitbucket Cloud Repository(remote repository)를 내 컴퓨터에 복사를 합니다.
&lt;/p&gt;
&lt;p&gt;
 저는 Atlassian의 Soruce Tree를 이용해서 Repository를 관리해보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.sourcetreeapp.com/&quot; rel=&quot;nofollow&quot;&gt;
  https://www.sourcetreeapp.com/
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/4&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Branch history를 그래프로 표시해주는 기능이 정말 편리합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 설치 완료 후 계정의 원격 저장소에서 앞에서 만든 Repository를 확인할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/5&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Repository옆에 작은 Clone 버튼으로 저장소를 내 컴퓨터에 복제합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/6&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이제 Jekyll을 설치하고 Blog를 생성하여 remote repository에 추가해 보겠습니다.
&lt;/p&gt;
&lt;h1 id=&quot;Bitbucketjekyll블로그만들기-Jekyll&quot;&gt;
 Jekyll
&lt;/h1&gt;
&lt;h2 id=&quot;Bitbucketjekyll블로그만들기-설치&quot;&gt;
 설치
&lt;/h2&gt;
&lt;blockquote&gt;
 &lt;p&gt;
  이 글의 ruby 버전은 2.4.4, jekyll은 3.6.2 입니다.
 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
 macOS 사용자는 쉽게 jekyll를 시작할 수 있습니다. macOS는 Ruby가 기본으로 설치되어 있거든요..
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://jekyllrb.com/docs/quickstart/&quot; rel=&quot;nofollow&quot;&gt;
  https://jekyllrb.com/docs/quickstart/
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Windows는 조금 더 작업을 해야 합니다. 자세한 과정은 아래 링크를 확인해 주세요.
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://jekyllrb.com/docs/windows/&quot; rel=&quot;nofollow&quot;&gt;
  https://jekyllrb.com/docs/windows/
 &lt;/a&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Ruby devkit installer를 이용하여 설치합니다.
 &lt;/li&gt;
 &lt;li&gt;
  Start command Propt with Ruby로 jekyll을 설치합니다.
  &lt;br/&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/44205100/7&quot;&gt;
  &lt;/span&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;Bitbucketjekyll블로그만들기-Jekylltheme적용&quot;&gt;
 Jekyll theme 적용
&lt;/h2&gt;
&lt;p&gt;
 처음부터 블로그를 만들기는 어렵기 때문에 기존에 인기 있는 jekyll 테마를 다운로드 받아서
&lt;/p&gt;
&lt;p&gt;
 새로 만든 blog에 적용해보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Jekyll theme중 인기있는 jasper를 적용해 보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/jekyller/jasper&quot; rel=&quot;nofollow&quot;&gt;
  https://github.com/jekyller/jasper
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Download zip으로 Source code를 다운로드 받습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/8&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 jekyll은 _data, _layout, _include, _post 등 소스코드로 _site를 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/9&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;Bitbucketjekyll블로그만들기-_config.yml수정&quot;&gt;
 _config.yml 수정
&lt;/h3&gt;
&lt;p&gt;
 Bitbucket 주소를 수정합니다.
&lt;/p&gt;
&lt;p&gt;
 short_url: '
 &lt;a class=&quot;external-link&quot; href=&quot;http://it2seiyon.bitbucket.io/&quot; rel=&quot;nofollow&quot;&gt;
  it2seiyon.bitbucket.io/
 &lt;/a&gt;
 '
&lt;/p&gt;
&lt;p&gt;
 baseurl: /
&lt;/p&gt;
&lt;p&gt;
 블로그를 효과적으로 운영하기 위해서는 많은 항목들을 수정해야합니다.
&lt;/p&gt;
&lt;p&gt;
 Google Analytic도 추가하고 댓글 기능도 추가할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Start Command Prompt with Ruby를 실행합니다. ( Ruby devkit으로 설치 )
&lt;/p&gt;
&lt;p&gt;
 Local Repository로 이동하여 theme에 필요한 패키지들을 설치합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: shell; gutter: false; theme: Confluence&quot; data-theme=&quot;Confluence&quot;&gt;cd C:\Users\sy\Downloads\jasper-master\jasper-master
C:\Users\sy\Downloads\jasper-master\jasper-master&gt;bundle install&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 패키지 설치 후 Local에 server를 띄워 확인해 보겠습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: shell; gutter: false; theme: Confluence&quot; data-theme=&quot;Confluence&quot;&gt;C:\Users\sy\Downloads\jasper-master\jasper-master&gt;bundle exec jekyll serve&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/10&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 기본 테마 환경으로 올라왔습니다.
&lt;/p&gt;
&lt;p&gt;
 이제 Remote Repository에 올리기 위해서 빌드를 실행합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: shell; gutter: false; theme: Confluence&quot; data-theme=&quot;Confluence&quot;&gt;C:\Users\sy\Downloads\jasper-master\jasper-master&gt;bundle exec jekyll build&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 빌드 후 jasper-pages 디렉터리가 생성됐습니다. _config.yml 설정에 의해서 생성되는 위치를 변경할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/11&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 jasper-pages의 파일들을 Local Repository에 복사합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/12&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h2 id=&quot;Bitbucketjekyll블로그만들기-RemoteRepository에추가&quot;&gt;
 Remote Repository에 추가
&lt;/h2&gt;
&lt;p&gt;
 Soruce Tree에서 추가된 소스를 확인할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/13&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 내 Local 스테이징 환경에 모두 추가합니다.
&lt;/p&gt;
&lt;p&gt;
 git 명령어로는 git add . 이 되겠습니다.
&lt;/p&gt;
&lt;p&gt;
 스테이지에 올린 후 커밋 메시지와 함께 커밋을 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 그리고 Push로 Remote Repository에 소스를 추가합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/14&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Bitbucket에서 추가된 소스코드를 확인할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/15&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 웹사이트를 확인해 보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://it2seiyon.bitbucket.io/&quot; rel=&quot;nofollow&quot;&gt;
  https://it2seiyon.bitbucket.io/
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/44205100/16&quot;&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 잘 나오네요. 앞으로 할 일은 블로그를 꾸미고 jekyll 빌드를 하고 생성된 소스를
&lt;/p&gt;
&lt;p&gt;
 Repo에 올리는 일입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;Bitbucketjekyll블로그만들기-마무리&quot;&gt;
 마무리
&lt;/h1&gt;
&lt;p&gt;
 Jekyll를 이용하여 웹 사이트를 생성하고 Bitbucket cloud에 Publishing을 해봤습니다.
&lt;/p&gt;
&lt;p&gt;
 Bitbucket colud로 blog를 운영할 때 장점이 아래와 같이 있습니다.
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Blog CSS, Javascript 수정
 &lt;/li&gt;
 &lt;li&gt;
  무제한 traffic
 &lt;/li&gt;
 &lt;li&gt;
  https 사용
 &lt;/li&gt;
 &lt;li&gt;
  무료 domain
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 Jekyll Theme를 수정해서 나만의 블로그를 빠르고 쉽게 만들 수 있는 방법입니다.
&lt;/p&gt;
&lt;p&gt;
 앞에 설명한 단계를 요약을 하면
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Bitbucket 가입
 &lt;/li&gt;
 &lt;li&gt;
  Repository 생성 ( .bitbucket.io 가 뒤에 붙습니다. )
  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
   &lt;li&gt;
    다른 repository를 생성하여 publishing 하고싶을 땐 team을 추가하여 진행하면 됩니다.
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
 &lt;li&gt;
  Sourece Tree 설치 (git 관리 프로그램)
  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
   &lt;li&gt;
    git clone
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
 &lt;li&gt;
  Jekyll 설치
 &lt;/li&gt;
 &lt;li&gt;
  Jekyll Theme 다운로드
 &lt;/li&gt;
 &lt;li&gt;
  Jekyll _config.yml 수정
 &lt;/li&gt;
 &lt;li&gt;
  Jekyll build
 &lt;/li&gt;
 &lt;li&gt;
  생성된 Sourece code  복사 → Local Repository 붙여 넣기
 &lt;/li&gt;
 &lt;li&gt;
  Sourece Tree에서 소스 스테이지환경 추가 → 커밋 → 푸시
 &lt;/li&gt;
 &lt;li&gt;
  내 Bitbucket page 확인 (
  &lt;a class=&quot;external-link&quot; href=&quot;https://it2seiyon.bitbucket.io/&quot; rel=&quot;nofollow&quot;&gt;
   https://it2seiyon.bitbucket.io/
  &lt;/a&gt;
  )
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Bitbucket cloud의 pipeline을 이용하면 더 많은 방법으로 응용이 가능합니다.
&lt;/p&gt;
&lt;p&gt;
 마무리 하겠습니다. Bibucket으로 Happy CI/CD 하세요~
&lt;/p&gt;
&lt;p&gt;
 감사합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Sun, 05 Aug 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/bitbucket/2018/08/05/44205100/</link>
        <guid isPermaLink="true">https://tech.osci.kr/bitbucket/2018/08/05/44205100/</guid>
        
        <category>git</category>
        
        <category>bitbucket</category>
        
        <category>blog</category>
        
        <category>jekyll</category>
        
        
        <category>bitbucket</category>
        
      </item>
    
      <item>
        <title>Confluence 6.11.0-beta Release Notes 분석</title>
        <description>&lt;p&gt;Confluence 6.11.0 beta가 릴리즈 됐습니다. 몇가지 큰 변화기 있는데요 한번 살펴보겠습니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;설치&quot;&gt;설치&lt;/h1&gt;
&lt;p&gt;다운로드 받아서 설치를 진행해 봤습니다.&lt;br /&gt;
아래 주소에서 다운로드 받을 수 있습니다.&lt;br /&gt;
https://www.atlassian.com/software/confluence/download-eap?&lt;br /&gt;
https://www.atlassian.com/software/confluence/downloads/binary/atlassian-confluence-6.11.0-beta1-x64.bin&lt;br /&gt;
&lt;img src=&quot;/assets/images/44204745/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 간단한게 Virtualbox에 vm 올려서 설치를 해보겠습니다.&lt;br /&gt;
저는 평소에 Virtualbox + Vagrant 조합을 사용해서 테스트를 하는데요 편하고 쉽습니다.&lt;br /&gt;
자주 사용하는 개발환경, 테스트환경은 provisioning script로 작성하여 git에서 관리하고 있습니다.&lt;br /&gt;
(언제 어디서나 테스트 환경을 뚝.딱! 만들 수 있습니다. from 좋은 선배)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44204745/2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;주요기능&quot;&gt;주요기능&lt;/h1&gt;
&lt;h2 id=&quot;첨부파일-edit&quot;&gt;첨부파일 edit&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;A better way to edit files
Confluence already lets you upload a wide range of files to share and discuss with your team. We’ve now made it easier to make changes to your files without the hassle of downloading and uploading multiple times.
You can now edit any file attached to a Confluence page using a desktop application, then save the file back to Confluence in a few clicks. And it’s not just available for Microsoft Offices documents; it works for Photoshop files, Keynote &amp;gt; &amp;gt; presentations — any attached file with a compatible application installed on your computer.
This feature replaces the Edit in Office function, which had some tricky limitations. It was restricted to Microsoft Office documents and only worked if you had the right browser, operating system and app combo running.
Read more in our guide to editing files.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 컴퓨터에 설치된 어플리케이션을 통해 업로드된 첨부파일을 편집할 수 있습니다.&lt;br /&gt;
 Microsoft Office 문서에만 사용할수있는 것은 아닙니다. Photoshop 파일, Keynote 등 컴퓨터에 설치된 호환 응용 프로그램이 있는 첨부파일에서 작동합니다.&lt;br /&gt;
 설치한 컨플루언스로 편집 기능을 이용해 보겠습니다.&lt;br /&gt;
 처음에는 Atlassian 프로그램을 설치해야 합니다. macOS도 지원하네요 : )&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/3&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치를 하구요.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/4&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어플리케이션을 실행하면 Status Bar에 작은 아틀라시안 아이콘이 생깁니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/5&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
 Confluence 에서 클라이언트로 접속을 허용 할건지 팝업이 뜹니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/6&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Trust로 허용 하면 연결 됐다는 메시지가 나옵니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/7&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Confluence로 돌아가서 Edit with를 누르면 Edit with Excel로 변경이 되어 있습니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/8&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Edit 버튼을 누르면 엑셀이 실행 되면서 편집을 할 수 있습니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/9&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
 Excel 파일을 수정 후 저장을 하게 되면&lt;br /&gt;
 Upload 버튼이 활성화 됩니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/10&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Upload를 하게되면 변경 사항에 Companion app으로 수정됐다는 이력이 기록됩니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/11&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아쉽지만 동시편집은 안됐습니다.&lt;br /&gt;
 엑셀 레벨에서 편집이 되기때문에 동시편집은 힘들겠죠?&lt;/p&gt;

&lt;p&gt;Keynote 파일도 편집을 해보겠습니다. Edit with Kenote 버튼이 활성화 되네요.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/12&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Keynote가 실행됩니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/13&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;변경 후 저장하면 Upload 버튼이 활성화 됩니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/14&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;변경이력 내용을 보면 Keynote 파일이 Companion app으로 업로드 됐다고 나옵니다.&lt;br /&gt;
 &lt;img src=&quot;/assets/images/44204745/15&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
 앞으로 Confluence는 다양한 어플리케이션과 작업할 수 있는 환경이 되겠네요. (엄지 척!)&lt;/p&gt;

&lt;h2 id=&quot;support-zip-생성이-쉬워졌습니다&quot;&gt;Support Zip 생성이 쉬워졌습니다.&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Easier ways to generate support zips   We’ve made it easier for you to create support zips from your site. A new REST API allows you to generate a support zip, and then download the zip remotely. You can even generate support zips from multiple nodes in your Data Center cluster with a single request.
We hope that this API will save a huge amount of time when you’re investigating an issue, and also opens up opportunities for automating support zip generation.
Find out how to generate a support zip via REST for Server or for Data Center.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;REST API를 통해서 Support Zip을 생성하고 다운로드 할 수 있다고 합니다. Data Center 버전에서는 여러 노드에서 Support Zip을 쉽게 만들 수 있을 것 같습니다.&lt;br /&gt;
자동화도 쉽게 할 수 있겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;data-center-버전에서-xml-backups-스케줄이-비활성화-되었습니다&quot;&gt;Data Center 버전에서 XML backups 스케줄이 비활성화 되었습니다.&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Scheduled XML backups disabled for Data Center   Having a robust backup strategy is essential. For small or test instances, the scheduled daily XML backup may be adequate, but once you’re running at scale we recommend you back up your database, install and home directories regularly. &lt;br /&gt;
In this release, we’ve disabled the daily XML backup for sites with a Data Center license.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;새로운-분석정보-제공-예정&quot;&gt;새로운 분석정보 제공 예정&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;New diagnostics info coming soon   After upgrading to Confluence 6.11, you may see some new messages in your application log, and a new  &lt;code&gt;   atlassian-diagnostics.log  &lt;/code&gt;  file, which is also included in support zips. This is related to new diagnostic information we’re working on, for things like low memory or disk space, or slow HTTP requests, long running tasks, or macro rendering. No action is required for these messages for now. &lt;br /&gt;
We plan to fine-tune the thresholds and provide a UI for this diagnostic information in an upcoming Confluence release.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Confluence 6.11로 업그레이드하면 새로운 atlassian-diagnostics.log를 확인할 수 있습니다.&lt;br /&gt;
이 로그는 느린 HTTP 요청, 메모리 또는 디스크 공간부족, 장기 실행 작업 또는 매크로 렌더링 관련하여 작업중인 진단 정보와 관련이 있습니다. 이 메시지에 대한 조치는 당장 필요하지 않습니다. 아틀라시안은 앞으로 릴리즈에서 임계 값을 미세 조정하고 진단 정보를 보여주는 UI를 제공 예정에 있다고 합니다. 반가운 소식입니다.&lt;/p&gt;

&lt;h2 id=&quot;지원하는-플랫폼-변경사항&quot;&gt;지원하는 플랫폼 변경사항&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Supported platforms changes &lt;br /&gt;
In this release we will be adding support for:&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;Oracle 12c R2&lt;/li&gt;
    &lt;li&gt;Microsoft SQL Server 2017&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Oralce 12c r2, MS SQL 2017을 지원합니다.&lt;/p&gt;

&lt;h1 id=&quot;wrap-up&quot;&gt;Wrap up&lt;/h1&gt;
&lt;p&gt;변화의 바람이 6.11에서 불어오네요. 첨부파일을 Edit할 수 있는 기능과 메모리 사용량, 느린 HTTP 요청 등 APM에서 제공하던 기능을 Confluence에서 제공 예정입니다.&lt;br /&gt;
Confluence를 사용하면서 조금 아쉽다 하는 부분을 예리하게 기능 추가/개선이 되는 것 같습니다.&lt;br /&gt;
지금까지 반가운 6.11 Beta Release 소식이었습니다.&lt;br /&gt;
감사합니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Aug 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2018/08/02/44204745/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2018/08/02/44204745/</guid>
        
        
      </item>
    
      <item>
        <title>리눅스 파일 시스템 이해하기 : ext4</title>
        <description>&lt;h1 id=&quot;원문-출처&quot;&gt;원문 출처&lt;/h1&gt;

&lt;p&gt;본 글은 아래의 링크에 대한 한글 번역본입니다. [https://opensource.com/article/18/4/ext4-filesystem]
&lt;img src=&quot;/files/post/filesystem/rh_003499_01_linux11x_cc.png&quot; alt=&quot;Image by : opensource.com&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전 배포판은 ext3, ext2 그리고 더 멀리 돌아가서 ext 를 기본으로 했었던 것처럼 현대 리눅스 배포판의 대부분은 ext4 파일시스템을 기본으로 합니다.
(역자주: 현재는 suse 계열은 btrfs로 centos계열은 xfs가 기본으로 변경되었음.)&lt;/p&gt;

&lt;p&gt;리눅스나 파일시스템이 처음 접한다면, ext3에 보다 추가된 ext4 기능에 대해 궁금할 것입니다. 또한, 현재 대안으로 나타나고 있는  btrfs, xfs, zfs에 비해 여전히 강점이 있는지도 궁금할 것입니다.&lt;/p&gt;

&lt;p&gt;이 문서에서 파일시스템에 대한 모든것을 다룰 수는 없겠지만 우리는 리눅스의 파일시스템을 간단히 살펴보고, 현황과 전망에 대해서 이야기 할것입니다. 이글은 위키 피디아와 ext4에 관한 kernel.org 사이트와 경험을 바탕으로 작성되었습니다.&lt;/p&gt;

&lt;h1 id=&quot;ext의-역사-요약&quot;&gt;ext의 역사 요약&lt;/h1&gt;
&lt;h2 id=&quot;minix-파일-시스템&quot;&gt;MINIX 파일 시스템&lt;/h2&gt;
&lt;p&gt;ext 파일시스템 전에, MINIX 파일 시스템이 있었습니다. MINIX는 IBM PC/AT 마이크로 컴퓨터를 위한 유닉스를 표방한 매우 작은  운영 체제였습니다. 1987년에 Andrew Tannenbaum은 교육 목적으로 MINIX를 개발하였고, 소스 코드를 발표했습니다.
&lt;img src=&quot;/files/post/filesystem/ibm_pc_at.jpg&quot; alt=&quot;IBM's mid-1980s PC/AT, MBlairMartin, CC BY-SA 4.0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MINIX의 소스코드를 보는것은 가능했지만, 그것은 실제 무료 오픈소스 소프트웨어(FOSS)는 아니였습니다.  Tannebaum의 책은 비용과 라이센스 금액를 합해서 69 달러에 판매되었습니다.  그러나,  그 당시로서는 파격적으로 저렴한 가격이여서,  원래목적이였던 간단한 교육목적을 넘어서 급속히 확산되었습니다.&lt;/p&gt;

&lt;p&gt;1990년대에 전 세계의 대학가에서 MINIX를 설치가 널리 퍼졌고, 이것은 Linux Torvalds는 1991년에 발표한 최초의 리눅스 커널 개발을 위해 MINIX 를 사용하였고, 이 리눅스커널을 1992년 12월에 GPL로 발표하게 됩니다.&lt;/p&gt;

&lt;p&gt;파일시스템 이야기로 돌아가보자면, MINIX는 자체 파일시스템이 있었고, 초기 리눅스 역시 같은 파일시스템이었으나, 이는 장난감 수준의 파일시스템이었습니다. — MINIX 파일 시스템은 파일이름은 14 문자만 가능했으며, 단지 64MB의 저장공간만의 사용이 가능했습니다. 1991년에 이미 하드 드라이브의 크기가 40-140MB 크기였으니, 리눅스에는 더 향상된 파일 시스템이 필요했습니다.&lt;/p&gt;

&lt;h2 id=&quot;ext&quot;&gt;ext&lt;/h2&gt;
&lt;p&gt;Linux는 리눅스 커널에 초보적인 파일시스템을 사용하는 동안, Rémy Card는 첫번째 ext 파일 시스템에서 만들게 됩니다. 1992년에 처음 구현된 ext 는 - 리눅스가 발표된지 1년도 안된 시점- MINIX의 가장 최악의 문제를 해결했습니다.&lt;/p&gt;

&lt;p&gt;1992년, ext는 Linux 커널에 새로운 추상화된 가상 파일 시스템 (VFS)을 사용했습니다. 이전의 MINIX 파일 시스템과 달리, ext은 최대 2GB의 저장 공간을 다룰 수 있고, 파일이름으로  255자를 사용할수 있었습니다.&lt;/p&gt;

&lt;p&gt;하지만 ext는 원시적인 타임스탬프(파일당 오직 한개의 타임스탬프- 오늘날 익숙한 3개의 타임스탬프 -inode ,파일 접근,수정 용도)때문에 ext는 불과 1년 후, ext2로 대체되게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;ext2&quot;&gt;ext2&lt;/h2&gt;
&lt;p&gt;Rémy는 ext 파일 시스템의 한계를 인식하고 그것을 대체하기 위한 ext2 파일 시스템은 설계하게 됩니다. ext는 장난감 수준이였지만 ext2는 BSD’s Berkeley Fast File System과 동일한 원칙을 따라 상업용 파일시스템으로 설계되었습니다.&lt;/p&gt;

&lt;p&gt;ext2는 파일크기가 gigabyte이상 파일시스템 크기는 terabyte 이상 사용가능하게 하며, 1990년대 파일시스템의 주류로 자리 잡았습니다. 빠르고 광범위하게 Linux커널과 MINIX 에도 채택되었으며, third-party 모듈을 통해 MacOS와 Windows에서 사용할 수 있도록 만들어졌습니다.&lt;/p&gt;

&lt;p&gt;하지만 ext2파일 시스템은 여전히 해결해야 할 문제가 있었는데 이는 1990년대의 대부분의 파일 시스템과 마찬가지로 데이터를 디스크에 쓰는 동안 시스템이 크래쉬 상황이나 전원이 끊어지면 심각한 손상을 입는다는 것이었습니다. 시간이 지남에 따라 단편화(여러 위치에 단일 파일을 물리적으로 회전 디스크에 분산 저장)로 인해 성능이 크게 저하되기도 했습니다.&lt;/p&gt;

&lt;p&gt;이러한 문제에도 불구하고 ext2는 오늘날에도 특수한 상황에서(가장 흔하게 휴대용 USB 드라이브 형태로) 여전히 사용되고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;ext3&quot;&gt;ext3&lt;/h2&gt;
&lt;p&gt;ext2를 채택된 지 6년 후인 1998년 Stephen Tweedie는 자신이 작업중인 상당히 개선된 버전의 파일시스템을 발표했습니다. 이것은 ext3로 2001년 11월에 리눅스 커널 버전 2.4.15에 채택되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/post/filesystem/packard_bell_pc.jpg&quot; alt=&quot;Mid-1990s Packard Bell computer, Spacekid, CC0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ext2는 대부분 Linux 배포 환경에서 매우 잘 실행되었지만 (FAT, FAT32, HFS및 다른 파일 시스템처럼) 정전 시 심각한 손상이 발생하기 쉬웠습니다. 파일 시스템에 데이터를 쓰는 동안 전원이 끊어지면 inconsistent state -(반은 쓰여졌고, 반은 쓰여지지 않은 상태)로 남게 됩니다. 이로 인해 저장되는 파일과 관련이 없는 큰 파일이 손실또는 손상되거나 심지어, 전체 파일시스템을 조작할수 없는 상태를 야기할수 있었습니다.&lt;/p&gt;

&lt;p&gt;1990년대 후반, Ext3과 Microsoft NTFS와 같은 파일 시스템은 이 문제를 journaling을 사용하여 해결하게 됩니다. journal은 write 트랜잭션이 일어나는 디스크에 특정영역을 할당해 두고, 트랜잭션이 디스크에 쓰는 것을 완료하면 journal안의 데이터를 commit하게 되고, 해당 작업이 commit 되기전에 시스템이 손상을 입는다면 새로 재부팅된 시스템은 이를 불완전한 처리로 인식하고 저널영역만 없애고, 기존 파일시스템의 영역은 원래상태로 남겨두는 작업을 하게 됩니다.&lt;/p&gt;

&lt;p&gt;즉, 작업 중인 파일이 여전히 손실될 수 있지만 파일 시스템 자체는 계속 일관되게 유지되고 다른 모든 데이터는 안전하게 보호됩니다. ext3의 리눅스 커널 구현에서 세가지 레벨의 journaling을 사용할 수 있습니다. 여기에는 Journal , Ordered 및 writeback 이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Journal은 가장 낮은 위험 모드로 파일 시스템에 commit하기 전에 데이터와 메타 데이터를 저널에 모두 기록합니다. 이렇게 하면 그 파일 시스템뿐만 아니라 전체까지 쓰여지는 파일의 일관성이 보장되지만 성능이 크게 저하될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;Ordered은 대부분의 Linux 배포에서 기본 모드입니다. ordered 모드는 journal에 메타 데이터를 쓰지만 파일 시스템에는 데이터를 직접 commit합니다. 이름이 암시하듯이, 작업 순서가 고정되어 있습니다. 첫째, 메타 데이터가 journal에 commit 되고 둘째, 데이터가 파일 시스템에 기록된 다음에서야 journal에 있는 연결된 메타 데이터가 파일 시스템 자체에 쓰여지게 됩니다. 이렇게 하면 문제 발생시 불완전한 쓰기와 관련된 메타 데이터가 저널에 계속 있고 파일 시스템이 저널을 롤백하여 이러한 불완전한 쓰기를 삭제할 수 있습니다. ordered 모드에서 충돌이 발생하면 충돌 중에 파일 또는 파일에 현재 기록되고 있는 파일이 손상될 수 있지만 파일 시스템 자체와 현재 기록 중이 아닌 파일은 안전하게 보호됩니다.&lt;/li&gt;
  &lt;li&gt;Writeback 은 세번째이자 가장 안전하지 않은 journaling 모드입니다. ordered 모드와 같이 writeback모드에서는 메타 데이터가 journal 되지만 데이터는 그렇지 않습니다. ordered 모드와는 달리 메타 데이터 및 데이터는 최상의 성능을 위해서는 어떤 순서로든 작성될 수 있습니다. 이렇게 하면 성능이 크게 향상될 수 있지만 훨씬 덜 안전합니다. writeback모드는 여전히 파일 시스템 자체에 안전을 보장하지만 장애 중 또는 장애 전 기록된 파일은 손실 또는 손상에 취약합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이전의 ext2와 마찬가지로 ext3은 16비트 내부 주소를 사용합니다. 즉, 블록 크기가 4K 인 경우 다룰 수 있는 가장 큰 파일크기는2TB이고,  최대 파일시스템 크기는 16TB입니다.&lt;/p&gt;

&lt;h2 id=&quot;ext4&quot;&gt;ext4&lt;/h2&gt;
&lt;p&gt;Theodore Ts’o(ext3의 핵심 개발자)는 2006년에 ext4 파일 시스템을 발표했고 2년 후 커널 버전 2.6.28d의 Linux에 추가되었습니다. Ts’o는 ext4가 ext3를 발전시킨 기술이지만 여전히 기존 기술에 의존한 중간단계이며, 결국 진정한 차세대 파일 시스템에 의해 대체될 것이라 이야기 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/post/filesystem/dell_precision_380_workstation.jpeg&quot; alt=&quot;Dell Precision 380 workstation, Lance Fisher, CC BY-SA 2.0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ext4는 기능적으로 ext3과 매우 유사하지만, 대용량 파일 시스템 지원을 제공하고 디스크 단편화에 대한 부분과 성능 증가, 타임 스탬프를 개선하였습니다.&lt;/p&gt;

&lt;h1 id=&quot;ext4-vs-ext3&quot;&gt;ext4 vs ext3&lt;/h1&gt;
&lt;p&gt;ext4와 ext3 파일 시스템에서 몇 가지 차이점이 존재하며 이 번 섹션에서 설명합니다.&lt;/p&gt;

&lt;h2 id=&quot;이전-버전과의-호환성&quot;&gt;이전 버전과의 호환성&lt;/h2&gt;
&lt;p&gt;ext4는 가능한 ext3으로 호환되도록 특별히 설계되었습니다. 이는 ext3파일 시스템을 ext4로 업그레이드할 수 있도록 할 뿐 아니라  ext4 드라이버가 자동으로 ext3 파일 시스템을 ext3 모드로 마운트 할 수 있으므로 두 코드베이스를 별도로 유지 관리 할 필요가 없습니다.&lt;/p&gt;

&lt;h2 id=&quot;large-filesystem&quot;&gt;Large filesystem&lt;/h2&gt;
&lt;p&gt;Ext3파일 시스템이 32비트 주소 지정을 사용하여 최대 2TiB 파일, 16TiB파일 시스템의 제약 사항이 존재합니다.(4KiB 블록 크기의 경우 몇몇 Ext3파일 시스템은 더 작은 블록을 사용합니다)&lt;/p&gt;

&lt;p&gt;ext4는 48비트 내부 주소 지정을 사용하여 최대 16TB의 파일을 파일시스템 1,000,000TiB( 1 EiB)까지  할당하는 것이 이론적으로 가능합니다. 일부 사용자 환경 유틸리티에 의해 초기 ext4는 16TiB파일 시스템으로 제한되었지만, 2011년부터 e2fsprogs를 통해 16TiB 이상의 ext4 파일 시스템 생성을 지원합니다. 한가지 예로, Red Hat Enterprise Linux는 공식적으로 ext4 파일 시스템을 최대 50TiB까지만 지원하며, 100TiB이하의 ext4 볼륨을 권장합니다.&lt;/p&gt;

&lt;h2 id=&quot;allocation-improvements&quot;&gt;Allocation Improvements&lt;/h2&gt;
&lt;p&gt;Ext4는 스토리지 블록들의 읽기 및 쓰기 성능이 크게 향상될 수 있도록 디스크에 데이터를 쓰기 전에 할당하는 방식의 많은 개선사항을 도입하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;extents-범위&quot;&gt;Extents (범위)&lt;/h3&gt;
&lt;p&gt;extent는 한번에 예약하여 처리할 수 있는 연속된 물리적 블록의 범위입니다. (4KiB 블록 크기라고 가정했을때 128MiB까지) extent 를 활용하면 지정된 파일에 필요한 inode들의 수을 줄이고 단편화를 감소시키며, 큰 용량의 파일을 쓸 때 성능을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;multiblock-allocation-멀티블록-할당&quot;&gt;Multiblock allocation (멀티블록 할당)&lt;/h3&gt;
&lt;p&gt;Ext3는 새로운 블록이 할당될 때마다 블록할당자를 호출했습니다. 이는 다수의 writer가 동시에 작업을 하는 경우 심한 단편화를 쉽게 발생하게 합니다. 하지만 ext4는 아직 commit 하지 않은 쓰기에 대해 어떻게 할당것인지에 더 나은 의사결정과 여러 개의 쓰기를 하나로 합치도록 지연 할당을 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;persistent-pre-allocation-지속적-사전-할당&quot;&gt;Persistent pre-allocation (지속적 사전 할당)&lt;/h3&gt;
&lt;p&gt;한 파일에 대해 파일에 대한 디스크 공간을 사전 할당할 때 대부분의 파일 시스템은 해당 블록에 0을 써야 합니다. ext4는 처음 쓰기 작업을 할 필요없이 공간 가용성을 확보(그리고 이를 위해 인접한 공간을 찾으려고 시도)하게 함으로써 fallocate()를 사용할 수 있도록 합니다. 이러한 작업은 스트리밍 및 데이터베이스 애플리케이션에 의해 기록된 데이터의 쓰기 및 향후 읽기 성능이 향상되도록 합니다.&lt;/p&gt;

&lt;h3 id=&quot;delayed-allocation-지연할당&quot;&gt;Delayed allocation (지연할당)&lt;/h3&gt;
&lt;p&gt;지연 할당은 논쟁의 여지가 있는 기능입니다. 지연 할당은 ext4가 데이터를 디스크에 커밋할 준비가 될 때 데이터를 쓸 실제 블록을 할당하도록 합니다. (반면에 ext3은 데이터가 여전히 쓰기 캐시로 유입되는 동안에도 즉시 블록을 할당합니다)&lt;/p&gt;

&lt;p&gt;캐쉬에 데이터가 누적될 때 블록 할당을 지연하는 것이 파일 시스템이 해당 블록을 할당하는 방법에 대해 보다 효율적으로 선택하여 단편화(쓰기 및 이후 읽기)를 줄이고 성능을 크게 향상합니다. 불행하게도, 프로그래머가 데이터가 디스크로 완전히 플러시 되는 것을 확인하려고 할 때, 특히 fsync()를 호출하도록 작성되지 않은 프로그램에서 데이터 손실 가능성을 높입니다.&lt;/p&gt;

&lt;p&gt;프로그램이 파일을 완전히 다시 쓴다고 가정해 봅시다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;file&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;O_TRUNC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;레거시 파일시스템의 close(fd) 는 디스크로 플러시될 file 의 내용을 보장하기에 충분합니다. 엄밀히 말하면, 비록 쓰기는 아니지만 파일을 닫은 후 충돌이 발생하면 데이터가 손실될 위험이 거의 없습니다.&lt;/p&gt;

&lt;p&gt;쓰기가 성공하지 못한다면 (프로그램 오류, 디스크 오류, 전원 손실)  파일의 새 버전과 원래 버전이 모두 손실되거나 손상될 수 있습니다. 다른 프로세스가 파일이 기록되는 동안 파일에 접근 하는 경우 손상된 버전을 보게됩니다. 또한 다른 프로세스에서 파일을 열어 놓고 해당 내용이 변경될 것으로 예상하지 않으면 실행 중인 여러 프로그램으로 매핑 된 공유 라이브러리가 충돌할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 피하기 위해 일부 프로그래머들은 O_TRUNC 를 전혀 사용하지 않습니다. 대신 새 파일에 쓰고 닫은 다음 이전 파일의 이름으로 바꿀겁니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;newfile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;newfile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;file&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;지연할당없는 파일 시스템은 위에서 설명한대로 잠재적 손상 및 충돌 문제를 방지하기에 충분합니다. rename() 은 atomic operation 이기 때문에 충돌에 의해 중단되지 않습니다 그리고 실행 중인 프로그램은 open filehandle 을 가지고 있는 한 이전의 지금은 링크되지않은 file 의 버전을 계속 참조합니다. 그러나 ext4의 지연 할당은 쓰기가 지연되고 순서를 변경할 수 있기때문에 rename(“newfile”, “file”) 은 newfile 의 내용이 실제로 디스크에 쓰여지기 전에 수행될 수 있어 file 의 잘못된 버전을 다시 가져오는 병렬 프로세스의 문제를 야기합니다.&lt;/p&gt;

&lt;p&gt;이를 완화하기 위해 Linux커널(2.6.30 이후)은 이러한 일반적인 코드 사례를 탐지하고 문제의 파일을 즉시 할당하려고 시도합니다. 따라서 데이터 손실의 가능성이 줄어들지만 이를 방지할 수는 없으며, 새 파일에는 전혀 도움이 되지 않습니다. 여러분이 만약 개발자인 경우 참고하셔야 할 내용이 있는데 데이터가 디스크에 즉시 기록되도록 보장하는 유일한 방법은 fsync() 를 알맞게 호출하는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;unlimited-subdirectories-무제한의-하위디렉토리&quot;&gt;Unlimited subdirectories (무제한의 하위디렉토리)&lt;/h3&gt;
&lt;p&gt;Ext3는 총 32,000개의 하위 디렉토리로 제한되어 있는 반면 ext4는 무제한의 숫자를 허용합니다.
커널 2.6.23으로 시작하는 ext4는 HTree 지수를 사용해 엄청난 수의 하위 디렉토리로 성능 손실을 완화합니다.&lt;/p&gt;

&lt;h3 id=&quot;journal-checksumming-journaling-체크섬&quot;&gt;Journal checksumming (journaling 체크섬)&lt;/h3&gt;
&lt;p&gt;Ext3은 커널의 직접 제어 범위를 벗어나 자체 캐시가 있는 디스크 또는 컨트롤러 장치에 문제가 발생한 저널의 체크섬을 하지 않습니다. 자체 캐시가 있는 컨트롤러나 디스크가 순서를 위반한 경우, Ext3의 journaling 트랜잭션 순서가 해제되어 충돌 동안(또는 이전 기간 동안) 쓰여지고있던 파일이 손상될 수 있습니다.&lt;/p&gt;

&lt;p&gt;이론적으로 이 문제는 파일 시스템이 마운트될 때 barrier=1 옵션을 사용하고 디바이스가 이후 fsync() 호출을 사용하여 쓰기에 대한 문제를 해결하였습니다. 실제로는 스토리지 디바이스와 컨트롤러의 쓰기 작업 성능 개선에 대해서는 어떨지 모르지만 데이터 손상을 막을 수 있는 방법에 대해서는 가능성을 열었습니다.&lt;/p&gt;

&lt;p&gt;저널을 체크섬 하는 것은 파일 시스템이 깨진 후에 일부 항목이 잘못되었거나 최초 마운트 이후 비순차적이거나 유효하지 않은 일부 항목들을 알 수 있도록 합니다. 이로 인해 문제가 발생하는 특정 저널 항목이나 일부 엔트리의 롤백을 피하고 더 나아가 파일시스템을 손상시키는 것을 방지합니다.&lt;/p&gt;

&lt;h3 id=&quot;fast-filesystem-checks-빠른-파일-시스템-검사&quot;&gt;Fast filesystem checks (빠른 파일 시스템 검사)&lt;/h3&gt;
&lt;p&gt;ext3에서 fsck를 할때 전체 파일시스템(삭제되거나 빈 파일까지 포함해서)을 확인합니다. 그에 반해 ext4는 할당되지 않은 블록과 inode 테이블의 섹션을 표시하므로 fsck를 완전히 건너 뛸 수 있습니다. 이렇게하면 대부분의 파일 시스템에서 fsck를 실행할 시간이 크게 줄어들게 되는데 이 기능은 커널 2.6.24부터 적용되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;improved-timestamps-개선-된-타임-스탬프&quot;&gt;Improved timestamps (개선 된 타임 스탬프)&lt;/h3&gt;
&lt;p&gt;Ext3는 시간 스탬프를 1초 단위로 세분화하여 제공합니다. 대부분의 경우 사용할 수 있는 반면, mission-critical 애플리케이션의 경우 보다 엄격한 시간 제어가 요구됩니다. Ext4는 나노초단위로 시간 스탬프를 제공함으로써 엔터프라이즈, 과학기술 영역과 mission-critical 애플리케이션에서 사용이 가능합니다.&lt;/p&gt;

&lt;p&gt;또한 Ext3 파일시스템은 2038년 1월 18일 이후로 날짜를 저장하기에 충분한 비트를 제공하지 않습니다. Ext4는 여기에 2비트를 더 추가하여  “유닉스 시대” 를 408년 더 연장합니다. 만일 2446년에 이것을 읽고 있다면, 아마 이미 더 나은 파일시스템으로 옮겨졌을 것입니다. — 하지만 1970년 1월 1일 UTC 00:00 이후로 시간을 계속 측정 중이라면 제가 죽은 후에라도 매우 기쁠 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;online-defragmentation-온라인-조각-모음&quot;&gt;Online defragmentation (온라인 조각 모음)&lt;/h3&gt;
&lt;p&gt;Ext2나 Ext3 모두 온라인 조각 모음을 직접 지원하지 않습니다. —  즉, 마운트된 동안 파일시스템을 조각모음하는 것. Ext2에는 이름에 함축 된대로 e2defrag 라는 유틸리티가 포함되어 있었습니다— 하지만, 파일 시스템을 마운트 하지 않은 상태에서 오프라인으로 실행해야 했습니다.(즉, 이것은 분명히 루트 파일 시스템에서 특히 문제가됩니다.) ext3은 심지어 ext2보다는 심각한 조각화로 인한 어려움을 훨씬 덜 겪었지만 ext3 파일 시스템에 대해 e2defrag를 실행하면 치명적인 손상과 데이터 손실을 초래할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ext3은 원래 “단편화에 영향을받지 않는것”으로 생각했지만 동일한 파일(예 : BitTorrent) 에 대용량 병렬 쓰기 를 하는 프로세스들은 그렇지 않은 것으로 입증되었습니다. Shake 와 같은 몇 가지 사용자 공간 해킹 및 해결 방법을 통해 이러한 문제를 해결했지만 실제 파일 시스템을 인식하는 커널 수준의 조각 모음 프로세스보다 속도가 느리고 다양한 방법으로 만족스럽지 않습니다.&lt;/p&gt;

&lt;p&gt;Ext4는 온라인, 커널 모드, 파일 시스템 인식, 블록 및 확장 수준의 조각 모음 유틸리티 인 e4defrag를 사용해 이 문제를 해결합니다.&lt;/p&gt;

&lt;h1 id=&quot;ongoing-ext4-development&quot;&gt;Ongoing ext4 development&lt;/h1&gt;
&lt;p&gt;Ext4는 Monty Python 병 피해자가 말했던 것처럼 “ 아직 안죽었어요!” 비록 그것의 주요 개발자는 그것을 진정한 차세대 파일시스템으로 가는 임시방편에 불과하다고 생각하지만 어느 누구도 한동안 root 파일 시스템으로 배치될 준비가 되지 않을 것입니다(기술이나 라이센스 문제때문에).&lt;/p&gt;

&lt;p&gt;메타 데이터의 체크섬, 1등급 할당량 지원 및 대형 할당 블록을 포함해, 아직도 몇가지 핵심적인 기능이 향후 버전의 ext4로 개발되고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;metadata-checksumming-메타-데이터-체크섬&quot;&gt;Metadata checksumming (메타 데이터 체크섬)&lt;/h2&gt;
&lt;p&gt;ext4는 여분의 수퍼블록을 가지고 있기 때문에  그 안의 메타 데이터를 체크섬 해서 주요 슈퍼블록이 손상되고 대체가 사용할 필요가 있는지 스스로 파악하는 방법을 제공합니다. 체크섬없이 손상된 수퍼 블록에서 복구 할 수는 있지만 사용자는 먼저 손상되었는지 확인한 다음 대체 시스템을 사용하여 파일 시스템을 수동으로 마운트해야합니다. 손상된 주요 수퍼 블록가진 파일시스템을  read-write로 마운트할 때 경우에 따라 더많은 손상이 발생할 수 있습니다. 파일 시스템을 마운트 할 때 손상된 기본 슈퍼 블록을 사용하여 읽기 - 쓰기가 가능하기 때문에 경우에 따라 더 많은 손상이 발생할 수 있습니다. 충분한 경험이있는 사용자라 할지라도 충분한 해결책은 아닙니다!&lt;/p&gt;

&lt;p&gt;btrfs 나 zfs같은 차세대 파일시스템이 제공하는 매우 강력한 블록단위 체크섬과 비교해서 ext4의 메타데이터 체크섬은 꽤 약한 기능입니다. 그러나 없는 것 보다는 훨씬 낫습니다.&lt;/p&gt;

&lt;p&gt;쉬운결정 처럼 들리지만 - 그래, 모든것을 체크섬해 ! - 파일시스템에 체크섬을 결합하는 것은 몇가지 중요한 도전입니다; 자세한 내용은 설계 문서를 참조하세요.&lt;/p&gt;

&lt;h2 id=&quot;first-class-quota-support&quot;&gt;First-class quota support&lt;/h2&gt;
&lt;p&gt;잠깐만, 할당량?! 우리는 ext2 시대이후로 그것들을 가지고 있습니다! 네, 하지만 그것들은 항상 뒤늦어져왔고 좀 별로였습니다. 아마도 여기서 어려운 세부사항으로 들어가는 것은 별로 좋지않지만 &lt;a href=&quot;https://ext4.wiki.kernel.org/index.php/Design_For_1st_Class_Quota_in_Ext4&quot;&gt;설계 문서&lt;/a&gt;는 할당량이 사용자 공간에서 커널로 이동하고 더 정학하고 효율적으로 시행되는 방식을 설명합니다.&lt;/p&gt;

&lt;h2 id=&quot;large-allocation-blocks-큰-할당-블록&quot;&gt;Large allocation blocks (큰 할당 블록)&lt;/h2&gt;
&lt;p&gt;시간이 지남에 따라 이런 성가신 저장 시스템은 점점 더 커지고 있습니다. 이미 8K 하드웨어 블록사이즈를 사용하는 solid-state drive의 경우 ext4의 4K 블록에 대한 현재의 제한이 점점 더 제한됩니다. 더 커진 스토리지 블록은 단편화를 줄이고 증가된 여유 공간을 희생해서 (파일 또는 파일의 마지막조각을 저장하기 위해 블록의 일부만 필요로할 때 남은 공간) 성능을 크게 향상시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ext4.wiki.kernel.org/index.php/Design_for_Large_Allocation_Blocks&quot;&gt;설계 문서&lt;/a&gt;에서 어려운 세부사항을 볼 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;practical-limitations-of-ext4&quot;&gt;Practical limitations of ext4&lt;/h1&gt;
&lt;p&gt;Ext4는 견고하고 안정적인 파일시스템이며 2018년에는 대부분의 사람들이 루트 파일 시스템으로 사용해야 할 것입니다. 그러나 모든것을 다룰 수는 없습니다. 지금부터 ext4에서 기대하지 말아야 하는 것들에 대해 간단하게 말씀드리겠습니다&lt;/p&gt;

&lt;p&gt;비록 ext4는 최대 1 EiB 의 데이터(1,000,000 TiB) 를 처리할 수 있지만 정말로 그렇게 시도하지는 말아야합니다. 단순히 더 많은 블록의 주소를 기억할 수 있는 것 이상의 규모 문제가 있으며 ext4는 현재 50-100 TiB 이상의 데이터를 처리할 수 없습니다. (아마 앞으로도 없을거같고)&lt;/p&gt;

&lt;p&gt;또한 Ext4는 데이터 무결성을 보장하기에 충분하지 않습니다. journaling 같은 큰 발전이 ext3 시대에 뒷받침하고있어 데이터손상의  일반적인 원인을 많이 다루지는 않습니다. 이미 디스크에 있는 동안 데이터가 손상되었다면 -결점이 있는 하드웨어, 우주광선의 영향(네, 진짜로), 또는 시간 경과에 따른 단순한 저하 - ext4는 그런 손상을 발견하거나 고칠 방법이없습니다.&lt;/p&gt;

&lt;p&gt;마지막 두개의 항목에 기초해서 ext4는 순수한 파일스템일 뿐이며 스토리지 볼륨 매니저가 아닙니다. 비록 다수의 디스크 -  그래서 이론적으로 손상된 데이터를 복구할 수 있는 패리티 또는 중복성-  가 있더라도 ext4는 그런 장점을 알거나 사용할 방법이 없다. 이론적으로 자동 손상 감지와 수리 기능을 잃지 않고 파일시스템과 스토리지 볼륨 관리시스템을 분리된 계층으로 나눌수  있지만 현재 스토리지 시스템은 그렇게 설계되어있지 않습니다. 그리고 새로운 디자인에 의미있는 도전이 될겁니다.&lt;/p&gt;

&lt;h1 id=&quot;alternate-filesystems&quot;&gt;Alternate filesystems&lt;/h1&gt;
&lt;p&gt;시작하기전에 주의사항: 배포판의 main 라인 커널의 일부로 내장되어 있지 않고 직접 지원하는 대체의 파일시스템을 매우 조심하세요!&lt;/p&gt;

&lt;p&gt;비록 파일시스템이 안정하더라도 루트파일시스템으로 사용하는 것은 커널 업그레이드 중에 간단한 문제가 발생한다면 매우 무서울 수 있습니다. 대체 미디어로 부팅하고 수동으로 꾸준히 커널모듈, grub 설정, chroot로 부터 DKMS를  찔러보는 생각에 편안하지않다면 중요한 시스템의 루트파일시스템은 마음편히 하지마세요.&lt;/p&gt;

&lt;p&gt;배포판에서 직접 지원하지 않는 파일시스템을 사용하는 것이 좋은 이유가 있을 수 있습니다 - 하지만 그렇게 한다면 시스템이 올라오고 사용할 수 있게 된후 마운트하길 강하게 추천드립니다. (예를 들어, ext4 루트 파일시스템을 가지고 있지만 데이터의 대부분은 zfs나 btrfs pool에 저장할 수 있습니다.&lt;/p&gt;

&lt;p&gt;배포판에서 직접 지원하지 않는 파일 시스템을 사용하는 것이 좋은 이유가있을 수 있습니다. 그렇다면 시스템을 사용하고 사용할 수있게 된 후에 마운트하는 것이 좋습니다. (예를 들어, ext4 루트 파일 시스템을 가지고 있지만 대부분의 데이터를 zfs 또는 btrfs 풀에 저장할 수 있습니다.)&lt;/p&gt;

&lt;h2 id=&quot;xfs&quot;&gt;XFS&lt;/h2&gt;
&lt;p&gt;XFS는 Linux 에서 사용되는 non-ext 파일시스템의 거의 main 라인급입니다. 2001 년부터 리눅스 커널에 내장 된 64 비트 저널링 파일 시스템이며 대용량 파일시스템에 높은 성능과 높은 동시성을 제공합니다(즉, 정말 많은 수의 프로세스가 한번에 파일 시스템에 기록합니다.)&lt;/p&gt;

&lt;p&gt;XFS는 RHEL7 부터 Red Hat Enterprise linux 의 기본 파일 시스템이 되었습니다. 가정이나 중소기업 사용자에게는 여전히 몇가지 단점이 있습니다.  - 특히 기존 XFS파일시스템 크기를 조정하는게 매우 어려우며, 일반적으로 또다른 곳을 만들고 데이터를 복사하는 것이 더 합리적입니다.&lt;/p&gt;

&lt;p&gt;XFS가 안정적이고 성능이 우수하지만 &amp;gt; 50TiB 용량 파일시스템같은 ext4가 가진 특정한 문제를 해결하지 않는 한, 기본 값(예:RHEL7)이 아닌 곳에서 사용을 권장하기에 ext4와의 구체적인 최종 사용 차이점이 없습니다.&lt;/p&gt;

&lt;p&gt;XFS는 ZFS, btrfs 또는 WAFL(독점 SAN 파일시스템) 같은 방법으로 “차세대” 파일시스템은 아닙니다. ext4처럼 더 나은 것을 향한 길을 따라 임시 방편으로 간주될 가능성이 가장 높습니다.&lt;/p&gt;

&lt;h2 id=&quot;zfs&quot;&gt;ZFS&lt;/h2&gt;
&lt;p&gt;ZFS는 Sun Microsystems에서 개발했으며 zettabyte -1조 기가와 동일 - 의 이름을 따서 명명되었으므로 이론적으로 큰 스토리지 시스템을 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;진정한 차세대 파일 시스템인 ZFS는 볼륨관리(단일 파일시스템에 여러개의 개별 저장 장치를 처리하는 기능), 블록 수준의 암호화 checksumming(매우 높은 정확도의 데이터 손상 탐지 가능), 자동 손상 복구(여분이나 패리티 스토리지가 사용가능한 곳), 신속한 비동기 증분 복제, 인라인 압축 등 훨씬 더 많이 제공합니다.&lt;/p&gt;

&lt;p&gt;Linux 사용자의 관점에서 ZFS의 가장 큰 문제는 라이센스입니다. ZFS는 GPL과 충돌하는 반영구 라이센스인 CDDL을 허용합니다. 리눅스 커널에서 ZFS를 사용하는 것의 의미에 대해서는 “GPL위반이다”, “CDDL 위반이다”부터 “완벽히 괜찮다 단지 법정에서 판단되지 않았을뿐이다” 까지 다양한 의견으로 많은 논쟁이 있습니다. 특히 Canonical 은 지금까지 합법적 신청없이 2016년 이후로 커널에 ZFS code 라인을 포함시켰습니다.&lt;/p&gt;

&lt;p&gt;현재로서는 열렬한 ZFS 사용자인데도 루트 파일시스템으로 ZFS를 추천하지 않습니다. 리눅스에 ZFS의 장점을 활용하려면 ext4에 소형 root 파일시스템을 설치한 후 나머지 저장공간에 ZFS를 설치하고 원하는 데이터, 애플리케이션을 배치합니다. - 다만, 배포판이 명시적으로 zfs를 root로 지원할때까지는 ext4를 root로 유지합니다.&lt;/p&gt;

&lt;h2 id=&quot;btrfs&quot;&gt;btrfs&lt;/h2&gt;
&lt;p&gt;B-Tree 파일시스템의 약자로 일반적으로 “butter”라고 발음하는 Btrfs 는 2007년에 Oracle 에서 재직중이던 Chris Mason 에 의해 발표되었습니다. Btrfs는 여러개의 장치 관리, 블록단위 checksumming, 비동기 복제, 인라인 압축 등등을 제공하는 ZFS와 거의 동일한 목표를 삼고 있습니다.&lt;/p&gt;

&lt;p&gt;2018년부터 btrfs는 상당히 안정적이고 표준 단일 시스템으로 사용할 수 있지만 볼륨 관리자로 의존하지는 않아야 합니다. 많은 일반적인 사용 사례에서 ext4, XFS 또는 ZFS에 비해 상당한 성능 문제가 발생하며,  차세대 기능(복제, 다중 디스크 토폴로지와 스냅샷 관리)은 비극적으로 감소된 성능부터 실제 데이터 손실에 이르기까지의 크게 결함이 있을 수 있습니다.&lt;/p&gt;

&lt;p&gt;진행중인 btrfs의 상태는 논란이 되고 있습니다. SUSE Enterprise Linux는 2015년에 기본 파일시스템으로 인정한 반면 Red Hat은 2017년 RHEL 7.4의 시작으로 btrfs를 지원하지 않는다고 발표했습니다. ZFS 같이 다중 디스크 볼륨 관리가 아닌 단일 디스크 파일시스템으로 btrfs의 운영과 지원되는 운영 환경 구축으로 사용하는 것에 주목할 가치가 있습니다. -  스토리지 어플라이언스에 btrfs를 사용하는 Synology도 기존의 Linux 커널 RAID (mdraid) 위에 계층화하여 디스크를 관리합니다.&lt;/p&gt;
</description>
        <pubDate>Tue, 31 Jul 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/linux/2018/07/31/linux-filesystem/</link>
        <guid isPermaLink="true">https://tech.osci.kr/linux/2018/07/31/linux-filesystem/</guid>
        
        <category>Linux</category>
        
        <category>File System</category>
        
        <category>Kernel</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>기술 블로그 PR을 받았습니다.</title>
        <description>&lt;p&gt;한통의 반가운 메일을 받았습니다.&lt;br /&gt;
Atlassian User Group에서 같이 활동하고 있는 이청규님께서 오픈소스컨설팅 기술 블로그에 PR(Pull request)을 보내 주셨습니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/44204215/0&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Pull request는 Master branch에 merge하기 위해 해당 Branch의 권한이 있는 사용자에게 review를 받고 Merge 합니다.&lt;br /&gt;
PR을 활용하여 좋은 문화를 구축할 수 있습니다.&lt;br /&gt;
Master branch에 merge할 수 있는 권한을 막고 reviewer에게 approve을 받아야만 merge할 수 있게 설정하여 review 문화를 구축할 수 있습니다.&lt;br /&gt;
저는 이 review 문화를 강력! 추천합니다. (2명이상 개발하면 무조건! 해요~)&lt;/p&gt;
&lt;h2 id=&quot;변경사항-확인-review를-해보아요&quot;&gt;변경사항 확인 (review를 해보아요)&lt;/h2&gt;
&lt;p&gt;청규님께서 무엇을 변경 했는지 확인할 수 있습니다. 변경전 후가 적색과 녹색으로 표시됩니다.&lt;br /&gt;
링크 형태를 markdown 으로 이쁘게 변경해 주셨습니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/44204215/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;approve&quot;&gt;Approve&lt;/h2&gt;
&lt;p&gt;저희 회사 기술 블로그는 Approve 1개 이상 받아야만 Master branch에 merge할 수 있는 규칙을 설정했습니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/44204215/2&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Review changes → Approve 를 하겠습니다. Review summary는 Looks good to merge +1 (LGTM +1) 을 남기겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;merge&quot;&gt;Merge&lt;/h2&gt;
&lt;p&gt;Reviewers의 approve가 체크되고 Merge pull request 버튼이 활성화 됐습니다.&lt;br /&gt;
Master branch에 merge를 했습니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/44204215/3&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;
&lt;p&gt;청규님의 PR로 README.md URL 포멧이 markdown 스럽게 변경 됐습니다.&lt;br /&gt;
https://github.com/OpenSourceConsulting/opensourceconsulting.github.io&lt;br /&gt;
소프트웨어는 견고하게 설계하고 만들어도 버그가 있기 마련입니다.&lt;br /&gt;
오픈소스의 장점은 이런 버그들도 오픈해서 전 세계 사람들이 해결하고 견고하게 하고 있습니다.&lt;br /&gt;
주위에 보면 Apache 재단의 오픈소스 프로젝트의 Contributor가 계시는데요.&lt;br /&gt;
처음에는 작은 PR로 시작을 하셨다고 합니다.&lt;br /&gt;
우리도 오픈소스를 사용하면서 불편했던 점, 버그 등을 PR(Pull request) 해보는건 어떨까요?&lt;/p&gt;

&lt;h3 id=&quot;감사합니다&quot;&gt;감사합니다.&lt;/h3&gt;
</description>
        <pubDate>Fri, 27 Jul 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/git/2018/07/27/44204215/</link>
        <guid isPermaLink="true">https://tech.osci.kr/git/2018/07/27/44204215/</guid>
        
        <category>git</category>
        
        <category>github</category>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>ConfluencePage CSS꾸미기</title>
        <description>&lt;h1 id=&quot;오픈소스컨설팅-기술-블로그&quot;&gt;오픈소스컨설팅 기술 블로그&lt;/h1&gt;
&lt;h2 id=&quot;기술을-나눕니다-함께-성장합니다&quot;&gt;기술을 나눕니다. 함께 성장합니다.&lt;/h2&gt;

&lt;p&gt;Confluence(이하 컨플루언스)는 간단한 방법으로 문서를 작성, 공유하는 도구입니다. 문서를 꾸미는데&lt;br /&gt;
시간을 낭비하지 않고 고객이 원하는 서비스를 구현, 지원하는데 모든 걸 쏟아붓습니다.&lt;/p&gt;

&lt;p&gt;하지만, 우리가 어떤 민족입니까. &lt;code class=&quot;highlighter-rouge&quot;&gt;멋&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;간지&lt;/code&gt;가 있어줘야 하지 않겠습니까. IT에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;멋&lt;/code&gt;을 CSS라고 부르더군요. w3schools.com의 CSS는 소개는 이렇습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CSS stands for Cascading Style Sheets&lt;br /&gt;
CSS describes how HTML elements are to be displayed on screen, paper, or in other media&lt;br /&gt;
CSS saves a lot of work. It can control the layout of multiple web pages all at once&lt;br /&gt;
External stylesheets are stored in CSS files&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;멋&lt;/code&gt;을 입힐 수 있다고합니다. 우리도 컨플루언스에 &lt;code class=&quot;highlighter-rouge&quot;&gt;멋&lt;/code&gt;을 좀 내볼까요?&lt;/p&gt;

&lt;h2 id=&quot;사전조건&quot;&gt;사전조건&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컨플루언스 관리자 (confluence-administrators)&lt;br /&gt;
CSS로 &lt;code class=&quot;highlighter-rouge&quot;&gt;멋&lt;/code&gt;을 내다보면 실수할 수도 있으니 운영시간 이외에 또는 테스트 환경에 우선 적용을 해보시기 바랍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;h1-제목에-스타일-입히고-전체-폰트-키우기&quot;&gt;h1 제목에 스타일 입히고 전체 폰트 키우기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/h1_css.png&quot; alt=&quot;Confluence CSS&quot; /&gt;&lt;br /&gt;
위 사진처럼 H1 제목에 강조하는 스타일을 적용하고 일반 텍스트 폰트 사이즈를 키워보겠습니다. 폰트가 작아서 좀 답답했거든요..&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Admin menu&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Look and feel&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Stylesheet&lt;/code&gt; 메뉴를 보시면&lt;br /&gt;
 &lt;img src=&quot;/assets/images/wiki_css_menu.png&quot; alt=&quot;Confluence Menu 위치&quot; /&gt;[width=200]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Global CSS를 입력할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;EDIT&lt;/code&gt; 버튼으로 CSS를 입력합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/wiki_css.png&quot; alt=&quot;Confluence Global Stylesheet&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /* main content는 page 글 부분입니다. */
#main-content h1{
  border-left: 5px solid black;
  padding-left: 5px;
}

/* 글씨 크기 키우기 */
#main-content p{
    font-size: 15px;
    padding-bottom: 5px; /* 글 간격 조정 */
}

/* 구두점 목록 글씨 크기 키우기 */
#main-content li {
  font-size: 15px;
  padding-bottom: 5px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드를 복사&amp;amp;붙여 넣기 후 바뀐 페이지를 확인할 수 있습니다.&lt;br /&gt;
Edit할 때는 보이지 않지만 저장 후 보여요 :)&lt;br /&gt;
간단한 방법으로 각자의 &lt;code class=&quot;highlighter-rouge&quot;&gt;멋&lt;/code&gt;을 추가해보시는건 어떨까요?&lt;/p&gt;

&lt;p&gt;오픈소스컨설팅&lt;br /&gt;
김세연&lt;br /&gt;
atlassian@osci.kr&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Jul 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/confluence,%20atlassian/2018/07/23/confluence-style/</link>
        <guid isPermaLink="true">https://tech.osci.kr/confluence,%20atlassian/2018/07/23/confluence-style/</guid>
        
        <category>Confluence</category>
        
        <category>Atlassian</category>
        
        <category>CSS</category>
        
        
        <category>Confluence, Atlassian</category>
        
      </item>
    
      <item>
        <title>Bamboo Agent 설정</title>
        <description>&lt;p&gt;Bamboo Agent로 Remote Server에서 Job을 실행할 수 있는 환경을 안내드립니다.&lt;br /&gt;
전체 순서는 아래와 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대상 서버에 Bamboo Agent 설치&lt;/li&gt;
  &lt;li&gt;Server capabilities 설정&lt;/li&gt;
  &lt;li&gt;Job 설정&lt;/li&gt;
  &lt;li&gt;결과 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;bamboo-agent-설치&quot;&gt;Bamboo Agent 설치&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;사전 조건
    &lt;ul&gt;
      &lt;li&gt;Bamboo Server ↔ Remote Server 방화벽 설정(proxy 사용 시 80, 8085, 54663)&lt;/li&gt;
      &lt;li&gt;Remote Server JDK 1.8 설치&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;관리자-메뉴의-agents&quot;&gt;관리자 메뉴의 Agents&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/0&quot; alt=&quot;관리자 메뉴&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;install-remote-agent&quot;&gt;Install remote agent&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/1&quot; alt=&quot;Install remote agent&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;agent-jar-파일을-다운로드-받아서-remote-server에서-실행합니다&quot;&gt;Agent JAR 파일을 다운로드 받아서 Remote Server에서 실행합니다.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#bamboo agent home directory를 생성합니다.   &lt;/span&gt;
/var/atlassian/application-data/bamboo-home  
&lt;span class=&quot;c&quot;&gt;#bamboo home path를 지정합니다.&lt;/span&gt;
java &lt;span class=&quot;nt&quot;&gt;-Dbamboo&lt;/span&gt;.home&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/atlassian/application-data/bamboo-home &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; atlassian-bamboo-agent-installer-6.6.1.jar http://13.209.93.233:8085/agentServer/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/3&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;bamboo-home에 bin, log등 파일 생성을 확인할 수 있습니다.
    &lt;h3 id=&quot;approve-this-agent-at-링크로-ip-승인&quot;&gt;Approve this agent at 링크로 IP 승인&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/4&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;등록된-remote-agent-확인&quot;&gt;등록된 Remote Agent 확인&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/5&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;server-capabilities&quot;&gt;Server capabilities&lt;/h2&gt;
&lt;p&gt;서버가 할 수 있는 작업들을 Key, Value 또는 환경을 정의합니다.&lt;br /&gt;
python, test 값으로 테스트 해보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;메뉴는-agents--shared-remote-capabilities-입니다&quot;&gt;메뉴는 Agents &amp;gt; Shared remote capabilities 입니다.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/6&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;key-value에-python-test를-추가합니다&quot;&gt;Key, Value에 python, test를 추가합니다.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/7&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 Remote Agent에 작업을 실행해 보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;job-설정&quot;&gt;Job 설정&lt;/h2&gt;
&lt;p&gt;Job에서 Requirements를 선택하여 사전에 정의한 python을 선택합니다.&lt;br /&gt;
아래 Python Code로 테스트를 진행 했습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#file wirte test#/opt/test.py&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/opt/pyText.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'w'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d line &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Task &amp;gt; Requirements 선택하여 Remote Agent의 capabilities에서 정의한 값 선택&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/8&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Script 명령어 작성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/9&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;결과확인&quot;&gt;결과확인&lt;/h2&gt;
&lt;h3 id=&quot;run-plan&quot;&gt;Run plan&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/10&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;remote-agent의-python-sample-code-실행-결과&quot;&gt;Remote Agent의 python sample code 실행 결과&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41553358/11&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버에 Agent 설치 부터 실행까지 해봤습니다. 중간에 capabilities 설정이 생소합니다.&lt;br /&gt;
Plan의 여러 Task들이 capabilities에 의해서 여러 Agent의 실행 결과에 따라 빌드를 수행할 수 있습니다.&lt;br /&gt;
API 빌드 결과에 따라서 다음 API 서버의 작업을 다르게 설정할 수 있는 유연한 계획을 수립할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Bamboo Server와 Agent간의 방화벽 허용도 중요합니다. Proxy서버에서 8085는 처리할 수 있지만 54663 포트는 proxy를 하지 않도록 권장하고 있습니다.&lt;/p&gt;

&lt;p&gt;Bamboo는 UI/UX가 군더더기 없고 깔끔해서 관리하기가 좋은 것 같습니다.
또한 Jira, Bitbucket과 강력한 통합 환경을 제공하는데요 이 내용은 다음에 공유하도록 하겠습니다.
감사합니다.&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Jul 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/ci/cd/2018/07/17/41553358/</link>
        <guid isPermaLink="true">https://tech.osci.kr/ci/cd/2018/07/17/41553358/</guid>
        
        <category>Bamboo</category>
        
        <category>CI/CD</category>
        
        <category>Atlassian</category>
        
        
        <category>CI/CD</category>
        
      </item>
    
      <item>
        <title>GitHub Page 블로그 이전</title>
        <description>&lt;h1 id=&quot;오픈소스컨설팅-기술-블로그&quot;&gt;오픈소스컨설팅 기술 블로그&lt;/h1&gt;
&lt;h2 id=&quot;기술을-나눕니다-함께-성장합니다&quot;&gt;기술을 나눕니다. 함께 성장합니다.&lt;/h2&gt;

&lt;h2 id=&quot;설명&quot;&gt;설명&lt;/h2&gt;
&lt;p&gt;기술 블로그를 GitHub Page로 이전 했습니다.&lt;br /&gt;
GitHub Page를 선택한 이유는 HTML, CSS, Javascript를 자유롭게 수정하고 싶었습니다.
하지만 Infra, Middleware를 구성은 만드는데 시간도 필요하고 유지보수 하기도 힘들고.. 그래서
GitHub Page를 선택했습니다. 우리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;글 쓰기에&lt;/code&gt; 집중하면서 무료 테마나 오픈소스로 Github에서 서비스 하면 됩니다.&lt;br /&gt;
우선 다른 블로그와 달리 &lt;code class=&quot;highlighter-rouge&quot;&gt;Git&lt;/code&gt;을 조금 알아야 하구요.
&lt;code class=&quot;highlighter-rouge&quot;&gt;MarkDown&lt;/code&gt;도 알아야 합니다. 어렵지 않습니다.&lt;br /&gt;
이 글이 도움이 되길 바랍니다.&lt;/p&gt;

&lt;h2 id=&quot;github-회원가입&quot;&gt;GitHub 회원가입&lt;/h2&gt;
&lt;p&gt;아직 가입 안하셨다면, 이번 기회에 가입해 보세요&lt;br /&gt;
오픈소스컨설팅 기술 블로그로 감을 익히시고 &lt;code class=&quot;highlighter-rouge&quot;&gt;개인 GitHub 블로그&lt;/code&gt; 운영도 해보세요 :)&lt;/p&gt;

&lt;h2 id=&quot;환경-구성&quot;&gt;환경 구성&lt;/h2&gt;
&lt;p&gt;Windows, Mac(Linux) 환경 구성 방법을 안내해 드리겠습니다.&lt;br /&gt;
환경 구성 후 GitHub에서 블로그 소스코드를 내려 받고,&lt;br /&gt;
글을 편집하고 GitHub에 올려 보겠습니다.
글 편집에는 Atom이라는 도구를 이용했지만 자유롭게 어떤 편집기든 가능합니다.(심지어 메모장 가능!)&lt;br /&gt;
이 과정이 어려우시면 오픈소스컨설팅 직원은 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://wiki.osci.kr/pages/viewpage.action?pageId=41553358&lt;/code&gt;에 올려주세요.
  우리 엔지니어들이 도와 드릴겁니다. 글이 중요하지 뭐가 중요하겠어요.&lt;/p&gt;

&lt;h3 id=&quot;설치-프로그램&quot;&gt;설치 프로그램&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Git (소스코드 관리)&lt;/li&gt;
  &lt;li&gt;Ruby (아름다운 언어)&lt;/li&gt;
  &lt;li&gt;jekyll (소스코드 빌드/서비스)&lt;/li&gt;
  &lt;li&gt;Atom (편집도구)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;windows&quot;&gt;Windows&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Git 설치 https://git-scm.com/download/win&lt;/li&gt;
  &lt;li&gt;Ruby 설치  https://github.com/oneclick/rubyinstaller2/releases/download/rubyinstaller-2.5.1-2/rubyinstaller-devkit-2.5.1-2-x64.exe&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Start Command Prompt with Ruby&lt;/code&gt; 실행&lt;/li&gt;
  &lt;li&gt;utf8 설정
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Users\sy\work&amp;gt;chcp 65001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;GitHub 블로그 Clone (폴더가 생성됩니다. 작업 위치 선정 필요합니다.)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Users\sy\work&amp;gt;git clone git@github.com:OpenSourceConsulting/opensourceconsulting.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;jekyll 설치
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Users\sy\work\opensourceconsulting.github.io&amp;gt;gem install bundler jekyll
Fetching: bundler-1.16.2.gem (100%)
Successfully installed bundler-1.16.2
Parsing documentation for bundler-1.16.2
Installing ri documentation for bundler-1.16.2
Done installing documentation for bundler after 11 seconds
Fetching: public_suffix-3.0.2.gem (100%)
Successfully installed public_suffix-3.0.2
Fetching: addressable-2.5.2.gem (100%)
Successfully installed addressable-2.5.2
Fetching: colorator-1.1.0.gem (100%)
Successfully installed colorator-1.1.0
Fetching: http_parser.rb-0.6.0.gem (100%)
MSYS2 could not be found. Please run 'ridk install'
or download and install MSYS2 manually from https://msys2.github.io/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;블로그 bundle install
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Users\sy\work\opensourceconsulting.github.io&amp;gt;bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;내 컴퓨터(local)에 jekyll build 및 서버 실행
    &lt;blockquote&gt;
      &lt;p&gt;jekyll build는 웹 사이트에 보여지는 코드를 생성한다.&lt;br /&gt;
우리는 build된 코드를 배포해야 한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  C:\Users\sy\work\opensourceconsulting.github.io&amp;gt;bundle exec jekyll serve

  Configuration file: C:/Users/sy/work/opensourceconsulting.github.io/_config.yml
     GitHub Metadata: No GitHub API authentication could be found. Some fields may be missing or have incorrect data.
              Source: C:/Users/sy/work/opensourceconsulting.github.io
         Destination: C:/Users/sy/work/opensourceconsulting.github.io/_site
   Incremental build: disabled. Enable with --incremental
        Generating...
                      done in 8.31 seconds.
   Auto-regeneration: enabled for 'C:/Users/sy/work/opensourceconsulting.github.io'
      Server address: http://127.0.0.1:4000/
    Server running... press ctrl-c to stop.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;macos&quot;&gt;macOS&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Git 설치 [https://git-scm.com/download/mac]&lt;/li&gt;
  &lt;li&gt;Ruby Version 확인
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; Ruby -v
ruby 2.3.3p222 (2016-11-21 revision 56859) [universal.x86_64-darwin17]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 설치
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; gem install bundler jekyll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;GitHub 저장소 복사
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;gt; git clone git@github.com:OpenSourceConsulting/opensourceconsulting.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;bundle install
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; opensourceconsulting.github.io&amp;gt;bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;내 컴퓨터(local)에 jekyll build 및 서버 실행
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; opensourceconsulting.github.io&amp;gt;bundle exec jekyll serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;글-쓰기-windows--macos&quot;&gt;글 쓰기 (Windows &amp;amp; macOS)&lt;/h3&gt;
&lt;p&gt;에디터는 Atom으로 진행하지만 편하신걸로 아무거나 괜찮습니다!&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Jira Issue key&lt;/code&gt;로 &lt;code class=&quot;highlighter-rouge&quot;&gt;브랜치를 생성&lt;/code&gt;하여 글을 작성하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pull Request&lt;/code&gt;로 작성한 글을 승인 받고 웹에 퍼블리싱하는 과정을 설명하겠습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Jira Issue 생성&lt;br /&gt;
 https://jira.osci.kr/secure/RapidBoard.jspa?rapidView=98&amp;amp;projectKey=TB
  이슈를 생성해 주세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Git Branch 생성&lt;br /&gt;
 블로그 위치에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b &amp;lt;issue key&amp;gt;&lt;/code&gt; 이슈키로 브랜치를 생성합니다.
 opensourceconsulting.github.io&amp;gt;git checkout TB-5&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Atom 설치 [ https://atom.io/ ]&lt;br /&gt;
 File &amp;gt; Open &amp;gt; opensourceconsulting.github.io &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;글 생성&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; 폴더에 yyyy-mm-dd-title.md 파일 생성&lt;br /&gt;
 다른 post의 header를 참고로 page 정보 기입&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마크다운&lt;br /&gt;
 ```&lt;br /&gt;
 # This is a H1&lt;br /&gt;
 ## This is a H2&lt;br /&gt;
 ### This is a H3&lt;br /&gt;
 #### This is a H4&lt;br /&gt;
 ##### This is a H5&lt;br /&gt;
 ###### This is a H6&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enter는 스페이스 2개&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; code block  
4개의 스페이스 또는 tab이 시작되고 끝나는 부분까지 코드로 인식
       ``` This is a normal paragraph: This is a code block. end code block. ```

       마크다운 링크 참고 https://gist.github.com/ihoneymon/652be052a0727ad59601
 - 이미지 첨부  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;/assets/images/ 경로에 이미지 파일 삽입
 ![이미지 설명]({{ “/assets/images/fileName.png” | absolute_url }})
 ```&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;글 작성 후 jekyll로 로컬에서 확인&lt;br /&gt;
    opensourceconsulting.github.io&amp;gt;bundle exec jekyll serve
http://127.0.0.1:4000/ post 확인&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;git status&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;opensourceconsulting.github.io&amp;gt;git status&lt;/code&gt; 수정한 파일을 확인합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;git add&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;opensourceconsulting.github.io&amp;gt;git add .&lt;/code&gt;수정된 파일 모두 Staging에 추가합니다. add 띄고 점이 있어요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;git commit&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;opensourceconsulting.github.io&amp;gt;git commit -m &quot;Update readme&quot;&lt;/code&gt; 수정된 파일 저장소에 저장합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-m&lt;/code&gt;은 commit message입니다. 동사로 시작하며 첫 문자만 대문자로 해주면 좋아요.(나중에 보기에 이뻐요…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;git push&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;opensourceconsulting.github.io&amp;gt;git push&lt;/code&gt; 원격 저장소에 생성한 브랜치를 업로드 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create Pull Request&lt;br /&gt;
GitHub에서 생성한 브랜치를 Master에 Merge를 요청합니다.&lt;br /&gt;
GitHub URL [https://github.com/OpenSourceConsulting/opensourceconsulting.github.io]&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/branch_1.png&quot; alt=&quot;Branch 메뉴&quot; /&gt;&lt;br /&gt;
branches 메뉴 선택&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/branch_2.png&quot; alt=&quot;New Pull Request&quot; /&gt;&lt;br /&gt;
Your branches에서 New pull request 버튼 클릭&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/branch_3.png&quot; alt=&quot;Open Pull Request&quot; /&gt;&lt;br /&gt;
Title에는 Jira 이슈키와 간단한 제목을 적어줍니다.&lt;br /&gt;
Description은 선택사항 입니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Create Pull Request&lt;/code&gt; 버튼으로 Pull Request를 생성합니다.&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GitHub&lt;/code&gt; 가입을 시작으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Git&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Jekyll&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Atom&lt;/code&gt;을 설치했습니다.&lt;br /&gt;
글을 작성하기 위해서 내 컴퓨터에 GitHub 원격 저장소를 &lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt; 명령어로 저장 했습니다.
Atom 에디터로 Post를 작성하기 위해서 Markdown을 습득했습니다.&lt;br /&gt;
글 작성이 완료되고 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;로 Staging 환경에 저장했습니다. Staging 환경에는 자주 저장해도 좋습니다.&lt;br /&gt;
모두 마무리가 됐다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;으로 저장소에 저장하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;로 원격 저장소에 업로드까지 했습니다.
마지막으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Create Pull Request&lt;/code&gt;로 Master 브랜치에 Merge까지 했습니다.
기술 블로그 글 작성을 통해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Git&lt;/code&gt;의 기본 기능과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Markdown&lt;/code&gt;을 익혀보시면 좋을 것 같습니다.&lt;br /&gt;
글은 작성하고 싶은데 과정이 어려우시다면  회사 Wiki에 작성 부탁드립니다.
글이 많이 작성 된다면 스크립트 만들어서 자동으로 넘기겠습니다.  &lt;code class=&quot;highlighter-rouge&quot;&gt;https://wiki.osci.kr/pages/viewpage.action?pageId=41553358&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Jul 2018 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/opensource,%20github,%20jekyll/2018/07/03/migration-github-blog/</link>
        <guid isPermaLink="true">https://tech.osci.kr/opensource,%20github,%20jekyll/2018/07/03/migration-github-blog/</guid>
        
        <category>GitHub</category>
        
        <category>Blog</category>
        
        <category>T-Story</category>
        
        <category>Jekyll</category>
        
        
        <category>OpenSource, GitHub, Jekyll</category>
        
      </item>
    
  </channel>
</rss>
